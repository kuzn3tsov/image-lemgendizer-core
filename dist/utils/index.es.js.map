{"version":3,"file":"index.es.js","sources":["../../src/utils/zipUtils.js","../../src/utils/imageUtils.js"],"sourcesContent":["/**\r\n * ZIP utility functions\r\n * @module utils/zipUtils\r\n */\r\n\r\n/**\r\n * Create a ZIP file with organized structure\r\n * @param {Array<LemGendImage>} processedImages - Array of processed LemGendImage objects\r\n * @param {Object} options - ZIP creation options\r\n * @param {boolean} options.includeOriginal - Include original images (default: true)\r\n * @param {boolean} options.includeOptimized - Include optimized versions (default: true)\r\n * @param {boolean} options.includeWebImages - Include web-optimized versions (default: true)\r\n * @param {boolean} options.includeLogoImages - Include logo versions (default: true)\r\n * @param {boolean} options.includeFaviconImages - Include favicon versions (default: true)\r\n * @param {boolean} options.includeSocialMedia - Include social media versions (default: true)\r\n * @param {boolean} options.createFolders - Create organized folder structure (default: true)\r\n * @param {boolean} options.includeInfoFile - Include INFO.txt with metadata (default: true)\r\n * @param {string} options.zipName - Custom ZIP filename (default: 'lemgendary-export')\r\n * @returns {Promise<Blob>} ZIP file as Blob\r\n */\r\nexport async function createLemGendaryZip(processedImages = [], options = {}) {\r\n    // Set default options\r\n    const defaultOptions = {\r\n        includeOriginal: true,\r\n        includeOptimized: true,\r\n        includeWebImages: true,\r\n        includeLogoImages: true,\r\n        includeFaviconImages: true,\r\n        includeSocialMedia: true,\r\n        createFolders: true,\r\n        includeInfoFile: true,\r\n        zipName: 'lemgendary-export',\r\n        skipEmptyFolders: true\r\n    }\r\n\r\n    const mergedOptions = { ...defaultOptions, ...options }\r\n\r\n    // Dynamically load JSZip to avoid dependency issues\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n    const now = new Date()\r\n    const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0]\r\n    const folderName = `${mergedOptions.zipName}-${timestamp}`\r\n\r\n    // Create main folder\r\n    const mainFolder = mergedOptions.createFolders\r\n        ? zip.folder(folderName)\r\n        : zip\r\n\r\n    // Define all possible folders with their conditions\r\n    const folderConfigs = [\r\n        {\r\n            name: '00_Originals',\r\n            condition: mergedOptions.includeOriginal,\r\n            files: await getOriginals(processedImages)\r\n        },\r\n        {\r\n            name: '01_Optimized',\r\n            condition: mergedOptions.includeOptimized,\r\n            files: await getOptimizedFiles(processedImages, 'optimized')\r\n        },\r\n        {\r\n            name: '02_Web_Images',\r\n            condition: mergedOptions.includeWebImages,\r\n            files: await getCategorizedFiles(processedImages, 'web')\r\n        },\r\n        {\r\n            name: '03_Logo_Images',\r\n            condition: mergedOptions.includeLogoImages,\r\n            files: await getCategorizedFiles(processedImages, 'logo')\r\n        },\r\n        {\r\n            name: '04_Favicon_Images',\r\n            condition: mergedOptions.includeFaviconImages,\r\n            files: await getCategorizedFiles(processedImages, 'favicon')\r\n        },\r\n        {\r\n            name: '05_Social_Media',\r\n            condition: mergedOptions.includeSocialMedia,\r\n            files: await getCategorizedFiles(processedImages, 'social')\r\n        }\r\n    ]\r\n\r\n    // Add files to folders, skipping empty ones if configured\r\n    for (const config of folderConfigs) {\r\n        if (config.condition && config.files.length > 0) {\r\n            const folder = mergedOptions.createFolders\r\n                ? mainFolder.folder(config.name)\r\n                : mainFolder\r\n\r\n            for (const fileData of config.files) {\r\n                const fileName = sanitizeFilename(fileData.name)\r\n                folder.file(fileName, fileData.content)\r\n            }\r\n        } else if (config.condition && config.files.length === 0 && mergedOptions.skipEmptyFolders) {\r\n            console.log(`Skipping empty folder: ${config.name}`)\r\n        }\r\n    }\r\n\r\n    // Add info file if requested\r\n    if (mergedOptions.includeInfoFile) {\r\n        const infoContent = generateInfoFileContent(processedImages, mergedOptions)\r\n        mainFolder.file('INFO.txt', infoContent)\r\n    }\r\n\r\n    // Generate ZIP\r\n    const zipBlob = await zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: {\r\n            level: 6\r\n        },\r\n        comment: `Created by LemGendary Image Processor - ${now.toISOString()}`,\r\n        platform: 'UNIX'\r\n    })\r\n\r\n    return zipBlob\r\n}\r\n\r\n/**\r\n * Get original files from LemGendImages\r\n * @private\r\n */\r\nasync function getOriginals(images) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        if (image.file && image.file instanceof File) {\r\n            files.push({\r\n                name: image.originalName || image.file.name,\r\n                content: image.file\r\n            })\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Get optimized files from LemGendImages\r\n * @private\r\n */\r\nasync function getOptimizedFiles(images, category) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        // Get outputs from the image\r\n        let outputs = []\r\n\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && typeof image.outputs.get === 'function') {\r\n            // Handle Map-based outputs\r\n            outputs = Array.from(image.outputs.values())\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        // Filter for optimized files (no template or custom category)\r\n        const optimizedOutputs = outputs.filter(output => {\r\n            return !output.template || output.template === 'custom' || output.category === category\r\n        })\r\n\r\n        for (const output of optimizedOutputs) {\r\n            if (output.file && output.file instanceof File) {\r\n                files.push({\r\n                    name: output.file.name || `optimized-${Date.now()}.${getFileExtension(output.file)}`,\r\n                    content: output.file\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Get categorized files from LemGendImages\r\n * @private\r\n */\r\nasync function getCategorizedFiles(images, category) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        // Get outputs from the image\r\n        let outputs = []\r\n\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && typeof image.outputs.get === 'function') {\r\n            // Handle Map-based outputs\r\n            outputs = Array.from(image.outputs.values())\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        // Filter by category\r\n        const categorizedOutputs = outputs.filter(output => {\r\n            const outputCategory = output.template?.category || output.category || ''\r\n            return outputCategory.toLowerCase() === category.toLowerCase()\r\n        })\r\n\r\n        for (const output of categorizedOutputs) {\r\n            if (output.file && output.file instanceof File) {\r\n                files.push({\r\n                    name: output.file.name || `${category}-${Date.now()}.${getFileExtension(output.file)}`,\r\n                    content: output.file\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Generate info file content\r\n * @private\r\n */\r\nfunction generateInfoFileContent(images, options) {\r\n    const now = new Date()\r\n\r\n    // Collect statistics\r\n    const stats = {\r\n        totalImages: images.length,\r\n        originals: 0,\r\n        optimized: 0,\r\n        web: 0,\r\n        logo: 0,\r\n        favicon: 0,\r\n        social: 0,\r\n        formats: {},\r\n        totalSize: 0\r\n    }\r\n\r\n    // Calculate statistics\r\n    for (const image of images) {\r\n        if (image.file) {\r\n            stats.originals++\r\n            stats.totalSize += image.file.size || 0\r\n        }\r\n\r\n        // Get outputs\r\n        let outputs = []\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        for (const output of outputs) {\r\n            if (output.file) {\r\n                stats.totalSize += output.file.size || 0\r\n\r\n                // Count by category\r\n                const category = output.template?.category || output.category || 'optimized'\r\n                switch (category.toLowerCase()) {\r\n                    case 'web': stats.web++; break\r\n                    case 'logo': stats.logo++; break\r\n                    case 'favicon': stats.favicon++; break\r\n                    case 'social': stats.social++; break\r\n                    default: stats.optimized++\r\n                }\r\n\r\n                // Count by format\r\n                const format = getFileExtension(output.file)\r\n                stats.formats[format] = (stats.formats[format] || 0) + 1\r\n            }\r\n        }\r\n    }\r\n\r\n    // Generate info text\r\n    const infoText = `LEMGENDARY IMAGE EXPORT\r\n===========================\r\n\r\nExport Information\r\n------------------\r\nDate: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}\r\nTool: LemGendary Image Processor\r\nVersion: 2.0.0\r\nExport ID: ${Date.now().toString(36).toUpperCase()}\r\n\r\nOptions Used\r\n------------\r\n${Object.entries(options)\r\n            .filter(([key]) => !['zipName'].includes(key))\r\n            .map(([key, value]) => `${key.padEnd(20)}: ${value}`)\r\n            .join('\\n')}\r\n\r\nStatistics\r\n----------\r\nTotal Images Processed: ${stats.totalImages}\r\nTotal Files in Export: ${stats.originals + stats.optimized + stats.web + stats.logo + stats.favicon + stats.social}\r\n\r\nFile Breakdown:\r\n  Original Images: ${stats.originals}\r\n  Optimized Images: ${stats.optimized}\r\n  Web Images: ${stats.web}\r\n  Logo Images: ${stats.logo}\r\n  Favicon Images: ${stats.favicon}\r\n  Social Media Images: ${stats.social}\r\n\r\nFormat Distribution:\r\n${Object.entries(stats.formats)\r\n            .map(([format, count]) => `  ${format.toUpperCase().padEnd(6)}: ${count} files`)\r\n            .join('\\n')}\r\n\r\nTotal Size: ${formatBytes(stats.totalSize)}\r\n\r\nImage Details\r\n-------------\r\n${images.map((img, index) => {\r\n                const outputs = typeof img.getAllOutputs === 'function' ? img.getAllOutputs() : []\r\n                return `[${index + 1}] ${img.originalName || 'Unnamed'}\r\n  Original: ${formatBytes(img.originalSize || 0)} | ${img.width || '?'}×${img.height || '?'}\r\n  Outputs: ${outputs.length} file(s)\r\n  ${outputs.map(out => `  - ${out.file?.name || 'Unnamed'} (${out.template?.category || 'custom'})`).join('\\n  ')}`\r\n            }).join('\\n\\n')}\r\n\r\nFolder Structure\r\n----------------\r\n${options.createFolders ? `\r\n00_Originals/       - Original uploaded images (${stats.originals > 0 ? stats.originals + ' files' : 'Skipped - empty'})\r\n01_Optimized/       - Custom processed images (${stats.optimized > 0 ? stats.optimized + ' files' : 'Skipped - empty'})\r\n02_Web_Images/      - Web template outputs (${stats.web > 0 ? stats.web + ' files' : 'Skipped - empty'})\r\n03_Logo_Images/     - Logo template outputs (${stats.logo > 0 ? stats.logo + ' files' : 'Skipped - empty'})\r\n04_Favicon_Images/  - Favicon template outputs (${stats.favicon > 0 ? stats.favicon + ' files' : 'Skipped - empty'})\r\n05_Social_Media/    - Social media platform outputs (${stats.social > 0 ? stats.social + ' files' : 'Skipped - empty'})`\r\n            : 'All files in root folder'}\r\n\r\nNotes\r\n-----\r\n• All processing done client-side in browser\r\n• No images uploaded to external servers\r\n• Created with LemGendary Image Processor\r\n• https://github.com/lemgenda/image-lemgendizer`\r\n\r\n    return infoText\r\n}\r\n\r\n/**\r\n * Format bytes to human-readable string\r\n * @private\r\n */\r\nfunction formatBytes(bytes, decimals = 2) {\r\n    if (bytes === 0) return '0 Bytes'\r\n\r\n    const k = 1024\r\n    const dm = decimals < 0 ? 0 : decimals\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\r\n\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]\r\n}\r\n\r\n/**\r\n * Get file extension from filename\r\n * @private\r\n */\r\nfunction getFileExtension(file) {\r\n    if (!file || !file.name) return 'unknown'\r\n\r\n    const parts = file.name.split('.')\r\n    if (parts.length > 1) {\r\n        return parts.pop().toLowerCase()\r\n    }\r\n\r\n    // Try to get from MIME type\r\n    const mimeMap = {\r\n        'image/jpeg': 'jpg',\r\n        'image/jpg': 'jpg',\r\n        'image/png': 'png',\r\n        'image/webp': 'webp',\r\n        'image/gif': 'gif',\r\n        'image/svg+xml': 'svg',\r\n        'image/bmp': 'bmp',\r\n        'image/tiff': 'tiff',\r\n        'image/x-icon': 'ico',\r\n        'image/avif': 'avif'\r\n    }\r\n\r\n    return mimeMap[file.type] || 'unknown'\r\n}\r\n\r\n/**\r\n * Sanitize filename for safe storage\r\n * @param {string} filename - Original filename\r\n * @returns {string} Sanitized filename\r\n */\r\nfunction sanitizeFilename(filename) {\r\n    if (!filename) return 'unnamed-file'\r\n\r\n    return filename\r\n        .replace(/[<>:\"/\\\\|?*]/g, '-')\r\n        .replace(/\\s+/g, '_')\r\n        .replace(/[^\\w.\\-]/g, '')\r\n        .substring(0, 255)\r\n        .trim()\r\n}\r\n\r\n/**\r\n * Create simple ZIP from file list\r\n * @param {Array<File>} files - Files to include in ZIP\r\n * @param {string} zipName - ZIP filename\r\n * @returns {Promise<Blob>} ZIP file as Blob\r\n */\r\nexport async function createSimpleZip(files = [], zipName = 'files') {\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n\r\n    for (const file of files) {\r\n        if (file && file instanceof File) {\r\n            zip.file(sanitizeFilename(file.name), file)\r\n        }\r\n    }\r\n\r\n    return zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: { level: 6 }\r\n    })\r\n}\r\n\r\n/**\r\n * Extract ZIP file\r\n * @param {Blob} zipBlob - ZIP file as Blob\r\n * @returns {Promise<Array>} Array of extracted files\r\n */\r\nexport async function extractZip(zipBlob) {\r\n    if (!(zipBlob instanceof Blob)) {\r\n        throw new Error('Input must be a Blob object')\r\n    }\r\n\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = await JSZip.loadAsync(zipBlob)\r\n    const files = []\r\n\r\n    // Process all files in ZIP\r\n    const filePromises = Object.keys(zip.files).map(async (filename) => {\r\n        const zipEntry = zip.files[filename]\r\n\r\n        if (!zipEntry.dir) {\r\n            try {\r\n                const content = await zipEntry.async('blob')\r\n                const mimeType = getMimeTypeFromExtension(filename)\r\n\r\n                const file = new File([content], filename, {\r\n                    type: mimeType,\r\n                    lastModified: zipEntry.date ? zipEntry.date.getTime() : Date.now()\r\n                })\r\n\r\n                files.push({\r\n                    name: filename,\r\n                    file: file,\r\n                    size: content.size,\r\n                    type: file.type,\r\n                    path: filename.includes('/') ? filename.split('/').slice(0, -1).join('/') : '',\r\n                    lastModified: zipEntry.date\r\n                })\r\n            } catch (error) {\r\n                console.warn(`Failed to extract file ${filename}:`, error)\r\n            }\r\n        }\r\n    })\r\n\r\n    await Promise.all(filePromises)\r\n    return files\r\n}\r\n\r\n/**\r\n * Get MIME type from file extension\r\n * @private\r\n */\r\nfunction getMimeTypeFromExtension(filename) {\r\n    const extension = filename.toLowerCase().split('.').pop()\r\n\r\n    const mimeTypes = {\r\n        // Images\r\n        'jpg': 'image/jpeg',\r\n        'jpeg': 'image/jpeg',\r\n        'png': 'image/png',\r\n        'webp': 'image/webp',\r\n        'gif': 'image/gif',\r\n        'svg': 'image/svg+xml',\r\n        'bmp': 'image/bmp',\r\n        'ico': 'image/x-icon',\r\n        'tiff': 'image/tiff',\r\n        'tif': 'image/tiff',\r\n        'avif': 'image/avif',\r\n\r\n        // Documents\r\n        'pdf': 'application/pdf',\r\n        'txt': 'text/plain',\r\n        'csv': 'text/csv',\r\n        'json': 'application/json',\r\n        'xml': 'application/xml',\r\n\r\n        // Archives\r\n        'zip': 'application/zip',\r\n        'rar': 'application/vnd.rar',\r\n        '7z': 'application/x-7z-compressed',\r\n\r\n        // Default\r\n        '': 'application/octet-stream'\r\n    }\r\n\r\n    return mimeTypes[extension] || 'application/octet-stream'\r\n}\r\n\r\n/**\r\n * Get ZIP file info without extracting\r\n * @param {Blob} zipBlob - ZIP file as Blob\r\n * @returns {Promise<Object>} ZIP information\r\n */\r\nexport async function getZipInfo(zipBlob) {\r\n    if (!(zipBlob instanceof Blob)) {\r\n        throw new Error('Input must be a Blob object')\r\n    }\r\n\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = await JSZip.loadAsync(zipBlob)\r\n\r\n    const files = []\r\n    let totalSize = 0\r\n    let fileCount = 0\r\n    let folderCount = 0\r\n\r\n    Object.keys(zip.files).forEach(filename => {\r\n        const zipEntry = zip.files[filename]\r\n\r\n        if (zipEntry.dir) {\r\n            folderCount++\r\n        } else {\r\n            fileCount++\r\n            const uncompressedSize = zipEntry._data.uncompressedSize || 0\r\n            totalSize += uncompressedSize\r\n\r\n            files.push({\r\n                name: filename,\r\n                size: uncompressedSize,\r\n                compressedSize: zipEntry._data.compressedSize || 0,\r\n                compressed: zipEntry._data.compression !== null,\r\n                directory: false,\r\n                lastModified: zipEntry.date,\r\n                ratio: uncompressedSize > 0\r\n                    ? ((uncompressedSize - zipEntry._data.compressedSize) / uncompressedSize * 100).toFixed(1)\r\n                    : 0\r\n            })\r\n        }\r\n    })\r\n\r\n    return {\r\n        fileCount,\r\n        folderCount,\r\n        totalSize,\r\n        compressedSize: zipBlob.size,\r\n        compressionRatio: totalSize > 0 ? (zipBlob.size / totalSize) : 0,\r\n        files,\r\n        comment: zip.comment || '',\r\n        format: 'ZIP',\r\n        isEncrypted: zip.password !== null,\r\n        timestamp: new Date().toISOString()\r\n    }\r\n}\r\n\r\n/**\r\n * Create ZIP with progress tracking\r\n * @param {Array} processedImages - Processed images\r\n * @param {Object} options - ZIP options\r\n * @param {Function} onProgress - Progress callback (0-1)\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createZipWithProgress(processedImages, options = {}, onProgress = null) {\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n    const folderName = options.zipName || `export-${Date.now()}`\r\n    const mainFolder = options.createFolders ? zip.folder(folderName) : zip\r\n\r\n    // Calculate total files for progress\r\n    const totalFiles = calculateTotalFiles(processedImages, options)\r\n    let filesAdded = 0\r\n\r\n    // Add files to ZIP with progress updates\r\n    if (options.includeOriginal) {\r\n        const originals = await getOriginals(processedImages)\r\n        for (const fileData of originals) {\r\n            mainFolder.file(sanitizeFilename(fileData.name), fileData.content)\r\n            filesAdded++\r\n\r\n            if (onProgress) {\r\n                onProgress(filesAdded / totalFiles, `Adding ${fileData.name}`)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add other file categories similarly\r\n    const categories = [\r\n        { name: 'optimized', getter: getOptimizedFiles },\r\n        { name: 'web', getter: (images) => getCategorizedFiles(images, 'web') },\r\n        { name: 'logo', getter: (images) => getCategorizedFiles(images, 'logo') },\r\n        { name: 'favicon', getter: (images) => getCategorizedFiles(images, 'favicon') },\r\n        { name: 'social', getter: (images) => getCategorizedFiles(images, 'social') }\r\n    ]\r\n\r\n    for (const category of categories) {\r\n        if (options[`include${category.name.charAt(0).toUpperCase() + category.name.slice(1)}`]) {\r\n            const files = await category.getter(processedImages)\r\n            const folder = options.createFolders ? mainFolder.folder(getFolderName(category.name)) : mainFolder\r\n\r\n            for (const fileData of files) {\r\n                folder.file(sanitizeFilename(fileData.name), fileData.content)\r\n                filesAdded++\r\n\r\n                if (onProgress) {\r\n                    onProgress(filesAdded / totalFiles, `Adding ${category.name}: ${fileData.name}`)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Generate ZIP with progress\r\n    return zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: { level: 6 }\r\n    }, (metadata) => {\r\n        if (onProgress) {\r\n            const fileProgress = filesAdded / totalFiles\r\n            const zipProgress = metadata.percent / 100\r\n            const overallProgress = fileProgress * 0.5 + zipProgress * 0.5\r\n            onProgress(overallProgress, `Compressing (${metadata.percent.toFixed(1)}%)`)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Calculate total files for progress tracking\r\n * @private\r\n */\r\nfunction calculateTotalFiles(images, options) {\r\n    let count = 0\r\n\r\n    // Count originals\r\n    if (options.includeOriginal) {\r\n        count += images.filter(img => img.file).length\r\n    }\r\n\r\n    // Count optimized/categorized files\r\n    for (const image of images) {\r\n        let outputs = []\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        for (const output of outputs) {\r\n            const category = output.template?.category || output.category || 'optimized'\r\n            const optionName = `include${category.charAt(0).toUpperCase() + category.slice(1)}`\r\n\r\n            if (options[optionName] !== false) {\r\n                count++\r\n            }\r\n        }\r\n    }\r\n\r\n    return Math.max(count, 1) // Ensure at least 1 for progress calculation\r\n}\r\n\r\n/**\r\n * Get folder name for category\r\n * @private\r\n */\r\nfunction getFolderName(category) {\r\n    const folderMap = {\r\n        'optimized': '01_Optimized',\r\n        'web': '02_Web_Images',\r\n        'logo': '03_Logo_Images',\r\n        'favicon': '04_Favicon_Images',\r\n        'social': '05_Social_Media'\r\n    }\r\n\r\n    return folderMap[category] || category\r\n}\r\n\r\n/**\r\n * Create optimized ZIP structure for custom processing\r\n * @param {Array} processedResults - Results from processing\r\n * @param {Object} options - ZIP options\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createCustomZip(processedResults, options = {}) {\r\n    const images = processedResults\r\n        .filter(result => result.success && result.image)\r\n        .map(result => result.image)\r\n\r\n    const customOptions = {\r\n        ...options,\r\n        includeWebImages: false,\r\n        includeLogoImages: false,\r\n        includeFaviconImages: false,\r\n        includeSocialMedia: false,\r\n        zipName: options.zipName || 'custom-processed'\r\n    }\r\n\r\n    return createLemGendaryZip(images, customOptions)\r\n}\r\n\r\n/**\r\n * Create template-based ZIP structure\r\n * @param {Array} templateResults - Results from template processing\r\n * @param {Object} options - ZIP options\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createTemplateZip(templateResults, options = {}) {\r\n    const images = templateResults\r\n        .filter(result => result.success && result.image)\r\n        .map(result => result.image)\r\n\r\n    const templateOptions = {\r\n        ...options,\r\n        zipName: options.zipName || 'template-export'\r\n    }\r\n\r\n    return createLemGendaryZip(images, templateOptions)\r\n}\r\n\r\nexport default {\r\n    createLemGendaryZip,\r\n    createSimpleZip,\r\n    extractZip,\r\n    getZipInfo,\r\n    createZipWithProgress,\r\n    createCustomZip,\r\n    createTemplateZip\r\n}","/**\r\n * Image utility functions\r\n * @module utils/imageUtils\r\n */\r\n\r\n/**\r\n * Get image dimensions from File\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Dimensions object\r\n */\r\nexport async function getImageDimensions(file) {\r\n    return new Promise((resolve, reject) => {\r\n        if (!file || !(file instanceof File)) {\r\n            reject(new Error('Invalid file provided'))\r\n            return\r\n        }\r\n\r\n        // Special handling for favicons\r\n        if (file.type === 'image/x-icon' || file.type === 'image/vnd.microsoft.icon') {\r\n            getIcoDimensions(file)\r\n                .then(resolve)\r\n                .catch(() => resolve({ width: 32, height: 32, orientation: 'square', aspectRatio: 1 }))\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const dimensions = {\r\n                width: img.naturalWidth || img.width,\r\n                height: img.naturalHeight || img.height,\r\n                orientation: img.naturalWidth >= img.naturalHeight ? 'landscape' : 'portrait',\r\n                aspectRatio: img.naturalWidth / img.naturalHeight\r\n            }\r\n\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(dimensions)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n\r\n            // For SVG files, try different approach\r\n            if (file.type === 'image/svg+xml') {\r\n                getSVGDimensions(file)\r\n                    .then(resolve)\r\n                    .catch(() => reject(new Error('Failed to load image dimensions')))\r\n            } else {\r\n                reject(new Error('Failed to load image'))\r\n            }\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Get SVG dimensions\r\n * @private\r\n */\r\nasync function getSVGDimensions(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n\r\n        reader.onload = (e) => {\r\n            try {\r\n                const svgText = e.target.result\r\n                const parser = new DOMParser()\r\n                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml')\r\n                const svgElement = svgDoc.documentElement\r\n\r\n                // Check for parsing errors\r\n                if (svgDoc.querySelector('parsererror')) {\r\n                    reject(new Error('Invalid SVG format'))\r\n                    return\r\n                }\r\n\r\n                // Get dimensions\r\n                const width = parseFloat(svgElement.getAttribute('width')) ||\r\n                    svgElement.viewBox?.baseVal?.width || 100\r\n                const height = parseFloat(svgElement.getAttribute('height')) ||\r\n                    svgElement.viewBox?.baseVal?.height || 100\r\n\r\n                resolve({\r\n                    width,\r\n                    height,\r\n                    orientation: width >= height ? 'landscape' : 'portrait',\r\n                    aspectRatio: width / height\r\n                })\r\n            } catch (error) {\r\n                reject(error)\r\n            }\r\n        }\r\n\r\n        reader.onerror = reject\r\n        reader.readAsText(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Get ICO file dimensions (simplified)\r\n * @private\r\n */\r\nasync function getIcoDimensions(file) {\r\n    return new Promise((resolve) => {\r\n        // ICO files can contain multiple sizes, return default for favicons\r\n        resolve({\r\n            width: 32,\r\n            height: 32,\r\n            orientation: 'square',\r\n            aspectRatio: 1\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * Check if image has transparency\r\n * @param {File} file - Image file\r\n * @returns {Promise<boolean>} True if image has transparency\r\n */\r\nexport async function hasTransparency(file) {\r\n    if (!file || (file.type !== 'image/png' && file.type !== 'image/webp')) {\r\n        return false // Only PNG and WebP have meaningful transparency for our purposes\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = img.width\r\n            canvas.height = img.height\r\n            const ctx = canvas.getContext('2d')\r\n            ctx.drawImage(img, 0, 0)\r\n\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\r\n            const data = imageData.data\r\n\r\n            // Check alpha channel\r\n            for (let i = 3; i < data.length; i += 4) {\r\n                if (data[i] < 255) {\r\n                    URL.revokeObjectURL(objectUrl)\r\n                    resolve(true)\r\n                    return\r\n                }\r\n            }\r\n\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(false)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(false)\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Convert File to Data URL\r\n * @param {File} file - File to convert\r\n * @returns {Promise<string>} Data URL\r\n */\r\nexport function fileToDataURL(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n        reader.onload = () => resolve(reader.result)\r\n        reader.onerror = reject\r\n        reader.readAsDataURL(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Convert Data URL to File\r\n * @param {string} dataURL - Data URL\r\n * @param {string} filename - Output filename\r\n * @returns {Promise<File>} File object\r\n */\r\nexport function dataURLtoFile(dataURL, filename) {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            const arr = dataURL.split(',')\r\n            const mime = arr[0].match(/:(.*?);/)[1]\r\n            const bstr = atob(arr[1])\r\n            let n = bstr.length\r\n            const u8arr = new Uint8Array(n)\r\n\r\n            while (n--) {\r\n                u8arr[n] = bstr.charCodeAt(n)\r\n            }\r\n\r\n            resolve(new File([u8arr], filename, { type: mime }))\r\n        } catch (error) {\r\n            reject(error)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Resize image using canvas\r\n * @param {File} file - Image file\r\n * @param {number} width - Target width\r\n * @param {number} height - Target height\r\n * @param {string} format - Output format\r\n * @param {number} quality - Quality (0-1)\r\n * @returns {Promise<File>} Resized image file\r\n */\r\nexport async function resizeImage(file, width, height, format = 'webp', quality = 0.8) {\r\n    return new Promise((resolve, reject) => {\r\n        // Special handling for favicon format\r\n        if (format.toLowerCase() === 'ico') {\r\n            // Create PNG first, then convert to ICO (simplified approach)\r\n            resizeImage(file, width, height, 'png', quality)\r\n                .then(pngFile => {\r\n                    // For now, return PNG and warn about ICO limitation\r\n                    console.warn('ICO format creation limited in browser. Using PNG instead.')\r\n                    resolve(pngFile)\r\n                })\r\n                .catch(reject)\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Fill background for JPEG\r\n            if (format === 'jpg' || format === 'jpeg') {\r\n                ctx.fillStyle = '#ffffff'\r\n                ctx.fillRect(0, 0, width, height)\r\n            }\r\n\r\n            ctx.drawImage(img, 0, 0, width, height)\r\n\r\n            // Determine MIME type\r\n            let mimeType\r\n            switch (format.toLowerCase()) {\r\n                case 'jpg':\r\n                case 'jpeg':\r\n                    mimeType = 'image/jpeg'\r\n                    break\r\n                case 'png':\r\n                    mimeType = 'image/png'\r\n                    break\r\n                case 'webp':\r\n                    mimeType = 'image/webp'\r\n                    break\r\n                case 'avif':\r\n                    mimeType = 'image/avif'\r\n                    break\r\n                case 'svg':\r\n                    mimeType = 'image/svg+xml'\r\n                    break\r\n                default:\r\n                    mimeType = 'image/webp'\r\n            }\r\n\r\n            canvas.toBlob(\r\n                (blob) => {\r\n                    URL.revokeObjectURL(objectUrl)\r\n\r\n                    if (!blob) {\r\n                        reject(new Error('Failed to create blob'))\r\n                        return\r\n                    }\r\n\r\n                    const extension = format.toLowerCase()\r\n                    const originalName = file.name.replace(/\\.[^/.]+$/, '')\r\n                    const newName = `${originalName}-${width}x${height}.${extension}`\r\n\r\n                    resolve(new File([blob], newName, { type: mimeType }))\r\n                },\r\n                mimeType,\r\n                quality\r\n            )\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to load image'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Crop image using canvas\r\n * @param {File} file - Image file\r\n * @param {number} x - X offset\r\n * @param {number} y - Y offset\r\n * @param {number} width - Crop width\r\n * @param {number} height - Crop height\r\n * @param {string} format - Output format\r\n * @param {number} quality - Quality (0-1)\r\n * @returns {Promise<File>} Cropped image file\r\n */\r\nexport async function cropImage(file, x, y, width, height, format = 'webp', quality = 0.8) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Fill background for JPEG\r\n            if (format === 'jpg' || format === 'jpeg') {\r\n                ctx.fillStyle = '#ffffff'\r\n                ctx.fillRect(0, 0, width, height)\r\n            }\r\n\r\n            ctx.drawImage(img, x, y, width, height, 0, 0, width, height)\r\n\r\n            // Determine MIME type\r\n            let mimeType\r\n            switch (format.toLowerCase()) {\r\n                case 'jpg':\r\n                case 'jpeg':\r\n                    mimeType = 'image/jpeg'\r\n                    break\r\n                case 'png':\r\n                    mimeType = 'image/png'\r\n                    break\r\n                case 'webp':\r\n                    mimeType = 'image/webp'\r\n                    break\r\n                default:\r\n                    mimeType = 'image/webp'\r\n            }\r\n\r\n            canvas.toBlob(\r\n                (blob) => {\r\n                    URL.revokeObjectURL(objectUrl)\r\n\r\n                    if (!blob) {\r\n                        reject(new Error('Failed to create blob'))\r\n                        return\r\n                    }\r\n\r\n                    const extension = format.toLowerCase()\r\n                    const originalName = file.name.replace(/\\.[^/.]+$/, '')\r\n                    const newName = `${originalName}-crop-${width}x${height}.${extension}`\r\n\r\n                    resolve(new File([blob], newName, { type: mimeType }))\r\n                },\r\n                mimeType,\r\n                quality\r\n            )\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to load image'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Calculate new dimensions maintaining aspect ratio\r\n * @param {number} originalWidth - Original width\r\n * @param {number} originalHeight - Original height\r\n * @param {number} targetSize - Target size (width or height)\r\n * @param {string} mode - 'width', 'height', or 'auto'\r\n * @returns {Object} New dimensions\r\n */\r\nexport function calculateAspectRatioFit(originalWidth, originalHeight, targetSize, mode = 'auto') {\r\n    if (mode === 'width') {\r\n        const newWidth = targetSize\r\n        const newHeight = Math.round((originalHeight / originalWidth) * targetSize)\r\n        return { width: newWidth, height: newHeight }\r\n    } else if (mode === 'height') {\r\n        const newHeight = targetSize\r\n        const newWidth = Math.round((originalWidth / originalHeight) * targetSize)\r\n        return { width: newWidth, height: newHeight }\r\n    } else {\r\n        // Auto mode: portrait uses height, landscape uses width\r\n        if (originalWidth >= originalHeight) {\r\n            const newWidth = targetSize\r\n            const newHeight = Math.round((originalHeight / originalWidth) * targetSize)\r\n            return { width: newWidth, height: newHeight }\r\n        } else {\r\n            const newHeight = targetSize\r\n            const newWidth = Math.round((originalWidth / originalHeight) * targetSize)\r\n            return { width: newWidth, height: newHeight }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Format file size for display\r\n * @param {number} bytes - File size in bytes\r\n * @param {number} decimals - Decimal places\r\n * @returns {string} Formatted size\r\n */\r\nexport function formatFileSize(bytes, decimals = 2) {\r\n    if (bytes === 0) return '0 Bytes'\r\n\r\n    const k = 1024\r\n    const dm = decimals < 0 ? 0 : decimals\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\r\n\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]\r\n}\r\n\r\n/**\r\n * Get file extension from filename or MIME type\r\n * @param {File|string} fileOrName - File object or filename\r\n * @returns {string} File extension\r\n */\r\nexport function getFileExtension(fileOrName) {\r\n    if (fileOrName instanceof File) {\r\n        // Try from name first\r\n        const nameExt = fileOrName.name.split('.').pop().toLowerCase()\r\n        if (nameExt && nameExt.length <= 4) {\r\n            return nameExt\r\n        }\r\n\r\n        // Fall back to MIME type\r\n        const mimeExt = {\r\n            'image/jpeg': 'jpg',\r\n            'image/jpg': 'jpg',\r\n            'image/png': 'png',\r\n            'image/webp': 'webp',\r\n            'image/gif': 'gif',\r\n            'image/svg+xml': 'svg',\r\n            'image/bmp': 'bmp',\r\n            'image/tiff': 'tiff',\r\n            'image/avif': 'avif',\r\n            'image/x-icon': 'ico',\r\n            'image/vnd.microsoft.icon': 'ico'\r\n        }[fileOrName.type]\r\n\r\n        return mimeExt || 'unknown'\r\n    }\r\n\r\n    // String input\r\n    const name = typeof fileOrName === 'string' ? fileOrName : ''\r\n    const ext = name.split('.').pop().toLowerCase()\r\n    return ext && ext.length <= 4 ? ext : 'unknown'\r\n}\r\n\r\n/**\r\n * Validate image file\r\n * @param {File} file - File to validate\r\n * @returns {Object} Validation result\r\n */\r\nexport function validateImageFile(file) {\r\n    const errors = []\r\n    const warnings = []\r\n\r\n    // Check if it's a File object\r\n    if (!(file instanceof File)) {\r\n        errors.push('Not a valid File object')\r\n        return { valid: false, errors, warnings }\r\n    }\r\n\r\n    // Check file type\r\n    const validTypes = [\r\n        'image/jpeg',\r\n        'image/jpg',\r\n        'image/png',\r\n        'image/webp',\r\n        'image/gif',\r\n        'image/svg+xml',\r\n        'image/bmp',\r\n        'image/tiff',\r\n        'image/avif',\r\n        'image/x-icon',\r\n        'image/vnd.microsoft.icon'\r\n    ]\r\n\r\n    if (!validTypes.includes(file.type)) {\r\n        errors.push(`Unsupported file type: ${file.type}`)\r\n    }\r\n\r\n    // Check file size\r\n    const maxSize = 50 * 1024 * 1024 // 50MB\r\n    if (file.size > maxSize) {\r\n        errors.push(`File too large: ${formatFileSize(file.size)} (max: ${formatFileSize(maxSize)})`)\r\n    } else if (file.size > 10 * 1024 * 1024) { // 10MB\r\n        warnings.push(`Large file: ${formatFileSize(file.size)} - processing may be slow`)\r\n    }\r\n\r\n    // Check filename\r\n    const invalidChars = /[<>:\"/\\\\|?*]/\r\n    if (invalidChars.test(file.name)) {\r\n        warnings.push('Filename contains invalid characters')\r\n    }\r\n\r\n    return {\r\n        valid: errors.length === 0,\r\n        errors,\r\n        warnings\r\n    }\r\n}\r\n\r\n/**\r\n * Create image thumbnail\r\n * @param {File} file - Image file\r\n * @param {number} maxSize - Maximum thumbnail dimension\r\n * @returns {Promise<string>} Thumbnail as Data URL\r\n */\r\nexport async function createThumbnail(file, maxSize = 200) {\r\n    return new Promise((resolve, reject) => {\r\n        // Special handling for favicons\r\n        if (file.type === 'image/x-icon' || file.type === 'image/vnd.microsoft.icon') {\r\n            // Use a default favicon icon as thumbnail\r\n            resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iIzM4ODJlZiIvPjxjaXJjbGUgY3g9IjEwMCIgY3k9IjEwMCIgcj0iNjAiIGZpbGw9IiNmZmYiLz48Y2lyY2xlIGN4PSIxMDAiIGN5PSIxMDAiIHI9IjQwIiBmaWxsPSIjMzg4MmVmIi8+PC9zdmc+')\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            // Calculate thumbnail dimensions\r\n            let width, height\r\n            if (img.width > img.height) {\r\n                width = maxSize\r\n                height = Math.round((img.height / img.width) * maxSize)\r\n            } else {\r\n                height = maxSize\r\n                width = Math.round((img.width / img.height) * maxSize)\r\n            }\r\n\r\n            // Create canvas for thumbnail\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Draw image\r\n            ctx.drawImage(img, 0, 0, width, height)\r\n\r\n            // Convert to Data URL\r\n            const thumbnail = canvas.toDataURL('image/jpeg', 0.7)\r\n\r\n            // Clean up\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(thumbnail)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to create thumbnail'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Batch process images with progress tracking\r\n * @param {Array<File>} files - Image files\r\n * @param {Function} processor - Processing function\r\n * @param {Function} onProgress - Progress callback\r\n * @returns {Promise<Array>} Processed results\r\n */\r\nexport async function batchProcess(files, processor, onProgress) {\r\n    const results = []\r\n    const total = files.length\r\n\r\n    for (let i = 0; i < files.length; i++) {\r\n        try {\r\n            const result = await processor(files[i], i)\r\n            results.push(result)\r\n\r\n            if (onProgress) {\r\n                onProgress((i + 1) / total, i + 1, total)\r\n            }\r\n        } catch (error) {\r\n            console.error(`Error processing file ${i + 1}:`, error)\r\n            results.push({ error: error.message, file: files[i] })\r\n        }\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n/**\r\n * Analyze image for optimization potential\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Optimization analysis\r\n */\r\nexport async function analyzeForOptimization(file) {\r\n    const dimensions = await getImageDimensions(file)\r\n    const transparency = await hasTransparency(file)\r\n\r\n    const analysis = {\r\n        dimensions,\r\n        transparency,\r\n        fileSize: file.size,\r\n        mimeType: file.type,\r\n        extension: getFileExtension(file),\r\n        optimizationScore: 0,\r\n        recommendations: []\r\n    }\r\n\r\n    // Calculate optimization score (0-100)\r\n    let score = 0\r\n\r\n    // Size-based scoring\r\n    if (file.size > 5 * 1024 * 1024) {\r\n        score += 40 // Large files have high optimization potential\r\n        analysis.recommendations.push('File is very large - high optimization potential')\r\n    } else if (file.size > 1 * 1024 * 1024) {\r\n        score += 20\r\n    } else if (file.size > 100 * 1024) {\r\n        score += 10\r\n    }\r\n\r\n    // Dimension-based scoring\r\n    const megapixels = (dimensions.width * dimensions.height) / 1000000\r\n    if (megapixels > 16) {\r\n        score += 30\r\n        analysis.recommendations.push('Very high resolution - consider resizing')\r\n    } else if (megapixels > 4) {\r\n        score += 15\r\n    }\r\n\r\n    // Format-based scoring\r\n    const modernFormats = ['webp', 'avif', 'svg']\r\n    const currentFormat = getFileExtension(file)\r\n    if (!modernFormats.includes(currentFormat)) {\r\n        score += 20\r\n        analysis.recommendations.push(`Consider converting from ${currentFormat} to modern format`)\r\n    }\r\n\r\n    // Transparency consideration\r\n    if (transparency && currentFormat === 'jpg') {\r\n        score += 10\r\n        analysis.recommendations.push('JPEG with transparency - convert to PNG or WebP')\r\n    }\r\n\r\n    analysis.optimizationScore = Math.min(100, score)\r\n    analysis.optimizationLevel = score > 50 ? 'high' : score > 25 ? 'medium' : 'low'\r\n\r\n    return analysis\r\n}\r\n\r\n/**\r\n * Get optimization presets for common use cases\r\n * @param {string} useCase - Use case identifier\r\n * @returns {Object} Optimization preset\r\n */\r\nexport function getOptimizationPreset(useCase) {\r\n    const presets = {\r\n        'web-high': {\r\n            quality: 85,\r\n            format: 'auto',\r\n            maxDisplayWidth: 1920,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: true,\r\n            description: 'High quality web images'\r\n        },\r\n        'web-balanced': {\r\n            quality: 80,\r\n            format: 'auto',\r\n            maxDisplayWidth: 1200,\r\n            compressionMode: 'adaptive',\r\n            stripMetadata: true,\r\n            description: 'Balanced web images'\r\n        },\r\n        'web-aggressive': {\r\n            quality: 70,\r\n            format: 'webp',\r\n            maxDisplayWidth: 800,\r\n            compressionMode: 'aggressive',\r\n            stripMetadata: true,\r\n            description: 'Aggressive web optimization'\r\n        },\r\n        'social-media': {\r\n            quality: 90,\r\n            format: 'jpg',\r\n            maxDisplayWidth: 1080,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: false, // Keep metadata for social\r\n            description: 'Social media images'\r\n        },\r\n        'ecommerce': {\r\n            quality: 92,\r\n            format: 'webp',\r\n            maxDisplayWidth: 1200,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: true,\r\n            preserveTransparency: true,\r\n            description: 'E-commerce product images'\r\n        },\r\n        'favicon': {\r\n            quality: 100,\r\n            format: 'ico',\r\n            compressionMode: 'balanced',\r\n            icoSizes: [16, 32, 48, 64],\r\n            description: 'Favicon generation'\r\n        },\r\n        'print-ready': {\r\n            quality: 100,\r\n            format: 'png',\r\n            compressionMode: 'balanced',\r\n            lossless: true,\r\n            stripMetadata: false,\r\n            description: 'Print-ready images'\r\n        },\r\n        'mobile-optimized': {\r\n            quality: 75,\r\n            format: 'webp',\r\n            maxDisplayWidth: 800,\r\n            compressionMode: 'aggressive',\r\n            stripMetadata: true,\r\n            description: 'Mobile-optimized images'\r\n        }\r\n    }\r\n\r\n    return presets[useCase] || presets['web-balanced']\r\n}\r\n\r\n/**\r\n * Calculate estimated optimization savings\r\n * @param {number} originalSize - Original file size in bytes\r\n * @param {Object} optimizationSettings - Optimization settings\r\n * @returns {Object} Estimated savings\r\n */\r\nexport function calculateOptimizationSavings(originalSize, optimizationSettings) {\r\n    const { format, quality, maxDisplayWidth } = optimizationSettings\r\n\r\n    let estimatedSize = originalSize\r\n    let reductionFactors = []\r\n\r\n    // Format reduction\r\n    switch (format) {\r\n        case 'webp':\r\n            estimatedSize *= 0.7\r\n            reductionFactors.push('WebP format: 30% reduction')\r\n            break\r\n        case 'avif':\r\n            estimatedSize *= 0.6\r\n            reductionFactors.push('AVIF format: 40% reduction')\r\n            break\r\n        case 'jpg':\r\n            estimatedSize *= 0.8\r\n            reductionFactors.push('JPEG format: 20% reduction')\r\n            break\r\n        case 'png':\r\n            estimatedSize *= 0.9\r\n            reductionFactors.push('PNG format: 10% reduction')\r\n            break\r\n        case 'svg':\r\n            estimatedSize *= 0.3\r\n            reductionFactors.push('SVG format: 70% reduction')\r\n            break\r\n        default:\r\n            estimatedSize *= 0.75\r\n            reductionFactors.push('Auto format selection: ~25% reduction')\r\n    }\r\n\r\n    // Quality reduction\r\n    const qualityFactor = quality / 100\r\n    estimatedSize *= qualityFactor\r\n    reductionFactors.push(`Quality ${quality}%: ${Math.round((1 - qualityFactor) * 100)}% reduction`)\r\n\r\n    // Display width reduction (if specified)\r\n    if (maxDisplayWidth) {\r\n        // Assume typical reduction for web display\r\n        estimatedSize *= 0.85\r\n        reductionFactors.push(`Max width ${maxDisplayWidth}px: ~15% reduction`)\r\n    }\r\n\r\n    const savings = originalSize - estimatedSize\r\n    const savingsPercent = (savings / originalSize) * 100\r\n\r\n    return {\r\n        originalSize,\r\n        estimatedSize: Math.round(estimatedSize),\r\n        savings: Math.round(savings),\r\n        savingsPercent: Math.round(savingsPercent * 10) / 10,\r\n        reductionFactors,\r\n        readable: {\r\n            original: formatFileSize(originalSize),\r\n            estimated: formatFileSize(Math.round(estimatedSize)),\r\n            savings: formatFileSize(Math.round(savings)),\r\n            savingsPercent: `${Math.round(savingsPercent * 10) / 10}%`\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Create optimization preview\r\n * @param {File} file - Image file\r\n * @param {Object} optimizationSettings - Optimization settings\r\n * @returns {Promise<string>} Data URL of optimized preview\r\n */\r\nexport async function createOptimizationPreview(file, optimizationSettings) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image()\r\n\r\n        img.onload = () => {\r\n            try {\r\n                const canvas = document.createElement('canvas')\r\n                const ctx = canvas.getContext('2d')\r\n\r\n                // Calculate preview dimensions (max 400px for preview)\r\n                const maxPreviewSize = 400\r\n                let width = img.width\r\n                let height = img.height\r\n\r\n                if (width > maxPreviewSize || height > maxPreviewSize) {\r\n                    if (width >= height) {\r\n                        width = maxPreviewSize\r\n                        height = Math.round((img.height / img.width) * maxPreviewSize)\r\n                    } else {\r\n                        height = maxPreviewSize\r\n                        width = Math.round((img.width / img.height) * maxPreviewSize)\r\n                    }\r\n                }\r\n\r\n                canvas.width = width\r\n                canvas.height = height\r\n\r\n                // Draw image\r\n                ctx.drawImage(img, 0, 0, width, height)\r\n\r\n                // Create preview with reduced quality\r\n                const previewQuality = Math.min(0.7, optimizationSettings.quality / 100 * 0.8)\r\n                const previewDataURL = canvas.toDataURL('image/jpeg', previewQuality)\r\n\r\n                resolve(previewDataURL)\r\n            } catch (error) {\r\n                reject(error)\r\n            }\r\n        }\r\n\r\n        img.onerror = reject\r\n        img.src = URL.createObjectURL(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Generate optimization comparison\r\n * @param {File} originalFile - Original image file\r\n * @param {File} optimizedFile - Optimized image file\r\n * @returns {Promise<Object>} Comparison data\r\n */\r\nexport async function generateOptimizationComparison(originalFile, optimizedFile) {\r\n    const originalSize = originalFile.size\r\n    const optimizedSize = optimizedFile.size\r\n    const savings = originalSize - optimizedSize\r\n    const savingsPercent = (savings / originalSize) * 100\r\n\r\n    // Get thumbnails for visual comparison\r\n    const originalThumbnail = await createThumbnail(originalFile, 300)\r\n    const optimizedThumbnail = await createThumbnail(optimizedFile, 300)\r\n\r\n    return {\r\n        original: {\r\n            size: originalSize,\r\n            sizeFormatted: formatFileSize(originalSize),\r\n            thumbnail: originalThumbnail\r\n        },\r\n        optimized: {\r\n            size: optimizedSize,\r\n            sizeFormatted: formatFileSize(optimizedSize),\r\n            thumbnail: optimizedThumbnail\r\n        },\r\n        savings: {\r\n            bytes: savings,\r\n            percent: Math.round(savingsPercent * 10) / 10,\r\n            formatted: formatFileSize(savings),\r\n            compressionRatio: (originalSize / optimizedSize).toFixed(2)\r\n        },\r\n        comparison: savingsPercent > 0 ?\r\n            `Saved ${formatFileSize(savings)} (${Math.round(savingsPercent)}%)` :\r\n            'No savings achieved'\r\n    }\r\n}\r\n\r\n/**\r\n * Check if image format needs conversion for web\r\n * @param {File} file - Image file\r\n * @returns {boolean} True if format conversion recommended\r\n */\r\nexport function needsFormatConversion(file) {\r\n    const extension = getFileExtension(file)\r\n    const modernFormats = ['webp', 'avif', 'svg']\r\n    return !modernFormats.includes(extension)\r\n}\r\n\r\n/**\r\n * Get recommended format for web\r\n * @param {File} file - Image file\r\n * @returns {string} Recommended format\r\n */\r\nexport function getRecommendedFormat(file) {\r\n    const extension = getFileExtension(file)\r\n\r\n    if (extension === 'svg') return 'svg'\r\n    if (extension === 'ico') return 'ico'\r\n\r\n    // Check if image has transparency\r\n    if (file.type === 'image/png' || file.type === 'image/webp') {\r\n        return 'webp' // WebP supports transparency\r\n    }\r\n\r\n    // For large images, recommend AVIF\r\n    if (file.size > 2 * 1024 * 1024) {\r\n        return 'avif'\r\n    }\r\n\r\n    return 'webp' // Default to WebP for good balance\r\n}\r\n\r\n/**\r\n * Get optimization quick stats\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Quick optimization stats\r\n */\r\nexport async function getOptimizationStats(file) {\r\n    const analysis = await analyzeForOptimization(file)\r\n    const recommendedFormat = getRecommendedFormat(file)\r\n    const savings = calculateOptimizationSavings(file.size, {\r\n        format: recommendedFormat,\r\n        quality: 85,\r\n        maxDisplayWidth: 1920\r\n    })\r\n\r\n    return {\r\n        analysis,\r\n        recommendedFormat,\r\n        estimatedSavings: savings,\r\n        needsOptimization: analysis.optimizationScore > 30,\r\n        priority: analysis.optimizationLevel\r\n    }\r\n}\r\n\r\nexport default {\r\n    getImageDimensions,\r\n    hasTransparency,\r\n    fileToDataURL,\r\n    dataURLtoFile,\r\n    resizeImage,\r\n    cropImage,\r\n    calculateAspectRatioFit,\r\n    formatFileSize,\r\n    getFileExtension,\r\n    validateImageFile,\r\n    createThumbnail,\r\n    batchProcess,\r\n    analyzeForOptimization,\r\n    getOptimizationPreset,\r\n    calculateOptimizationSavings,\r\n    createOptimizationPreview,\r\n    generateOptimizationComparison,\r\n    needsFormatConversion,\r\n    getRecommendedFormat,\r\n    getOptimizationStats\r\n}"],"names":["createLemGendaryZip","processedImages","options","mergedOptions","JSZip","zip","now","timestamp","folderName","mainFolder","folderConfigs","getOriginals","getOptimizedFiles","getCategorizedFiles","config","folder","fileData","fileName","sanitizeFilename","infoContent","generateInfoFileContent","images","files","image","category","outputs","optimizedOutputs","output","getFileExtension","categorizedOutputs","stats","format","key","value","count","formatBytes","img","index","out","bytes","decimals","k","dm","sizes","i","file","parts","filename","createSimpleZip","zipName","extractZip","zipBlob","filePromises","zipEntry","content","mimeType","getMimeTypeFromExtension","error","extension","getZipInfo","totalSize","fileCount","folderCount","uncompressedSize","createZipWithProgress","onProgress","totalFiles","calculateTotalFiles","filesAdded","originals","categories","getFolderName","metadata","fileProgress","zipProgress","overallProgress","optionName","createCustomZip","processedResults","result","customOptions","createTemplateZip","templateResults","templateOptions","zipUtils","getImageDimensions","resolve","reject","getIcoDimensions","objectUrl","dimensions","getSVGDimensions","reader","e","svgText","svgDoc","svgElement","width","height","hasTransparency","canvas","ctx","data","fileToDataURL","dataURLtoFile","dataURL","arr","mime","bstr","n","u8arr","resizeImage","quality","pngFile","blob","newName","cropImage","x","y","calculateAspectRatioFit","originalWidth","originalHeight","targetSize","mode","newWidth","newHeight","formatFileSize","fileOrName","nameExt","ext","validateImageFile","errors","warnings","maxSize","createThumbnail","thumbnail","batchProcess","processor","results","total","analyzeForOptimization","transparency","analysis","score","megapixels","modernFormats","currentFormat","getOptimizationPreset","useCase","presets","calculateOptimizationSavings","originalSize","optimizationSettings","maxDisplayWidth","estimatedSize","reductionFactors","qualityFactor","savings","savingsPercent","createOptimizationPreview","maxPreviewSize","previewQuality","previewDataURL","generateOptimizationComparison","originalFile","optimizedFile","optimizedSize","originalThumbnail","optimizedThumbnail","needsFormatConversion","getRecommendedFormat","getOptimizationStats","recommendedFormat","imageUtils"],"mappings":"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"}