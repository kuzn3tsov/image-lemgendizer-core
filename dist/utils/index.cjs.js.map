{"version":3,"file":"index.cjs.js","sources":["../../src/utils/zipUtils.js","../../src/utils/imageUtils.js"],"sourcesContent":["/**\r\n * ZIP utility functions\r\n * @module utils/zipUtils\r\n */\r\n\r\n/**\r\n * Create a ZIP file with organized structure\r\n * @param {Array<LemGendImage>} processedImages - Array of processed LemGendImage objects\r\n * @param {Object} options - ZIP creation options\r\n * @param {boolean} options.includeOriginal - Include original images (default: true)\r\n * @param {boolean} options.includeOptimized - Include optimized versions (default: true)\r\n * @param {boolean} options.includeWebImages - Include web-optimized versions (default: true)\r\n * @param {boolean} options.includeLogoImages - Include logo versions (default: true)\r\n * @param {boolean} options.includeFaviconImages - Include favicon versions (default: true)\r\n * @param {boolean} options.includeSocialMedia - Include social media versions (default: true)\r\n * @param {boolean} options.createFolders - Create organized folder structure (default: true)\r\n * @param {boolean} options.includeInfoFile - Include INFO.txt with metadata (default: true)\r\n * @param {string} options.zipName - Custom ZIP filename (default: 'lemgendary-export')\r\n * @returns {Promise<Blob>} ZIP file as Blob\r\n */\r\nexport async function createLemGendaryZip(processedImages = [], options = {}) {\r\n    // Set default options\r\n    const defaultOptions = {\r\n        includeOriginal: true,\r\n        includeOptimized: true,\r\n        includeWebImages: true,\r\n        includeLogoImages: true,\r\n        includeFaviconImages: true,\r\n        includeSocialMedia: true,\r\n        createFolders: true,\r\n        includeInfoFile: true,\r\n        zipName: 'lemgendary-export',\r\n        skipEmptyFolders: true\r\n    }\r\n\r\n    const mergedOptions = { ...defaultOptions, ...options }\r\n\r\n    // Dynamically load JSZip to avoid dependency issues\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n    const now = new Date()\r\n    const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0]\r\n    const folderName = `${mergedOptions.zipName}-${timestamp}`\r\n\r\n    // Create main folder\r\n    const mainFolder = mergedOptions.createFolders\r\n        ? zip.folder(folderName)\r\n        : zip\r\n\r\n    // Define all possible folders with their conditions\r\n    const folderConfigs = [\r\n        {\r\n            name: '00_Originals',\r\n            condition: mergedOptions.includeOriginal,\r\n            files: await getOriginals(processedImages)\r\n        },\r\n        {\r\n            name: '01_Optimized',\r\n            condition: mergedOptions.includeOptimized,\r\n            files: await getOptimizedFiles(processedImages, 'optimized')\r\n        },\r\n        {\r\n            name: '02_Web_Images',\r\n            condition: mergedOptions.includeWebImages,\r\n            files: await getCategorizedFiles(processedImages, 'web')\r\n        },\r\n        {\r\n            name: '03_Logo_Images',\r\n            condition: mergedOptions.includeLogoImages,\r\n            files: await getCategorizedFiles(processedImages, 'logo')\r\n        },\r\n        {\r\n            name: '04_Favicon_Images',\r\n            condition: mergedOptions.includeFaviconImages,\r\n            files: await getCategorizedFiles(processedImages, 'favicon')\r\n        },\r\n        {\r\n            name: '05_Social_Media',\r\n            condition: mergedOptions.includeSocialMedia,\r\n            files: await getCategorizedFiles(processedImages, 'social')\r\n        }\r\n    ]\r\n\r\n    // Add files to folders, skipping empty ones if configured\r\n    for (const config of folderConfigs) {\r\n        if (config.condition && config.files.length > 0) {\r\n            const folder = mergedOptions.createFolders\r\n                ? mainFolder.folder(config.name)\r\n                : mainFolder\r\n\r\n            for (const fileData of config.files) {\r\n                const fileName = sanitizeFilename(fileData.name)\r\n                folder.file(fileName, fileData.content)\r\n            }\r\n        } else if (config.condition && config.files.length === 0 && mergedOptions.skipEmptyFolders) {\r\n            console.log(`Skipping empty folder: ${config.name}`)\r\n        }\r\n    }\r\n\r\n    // Add info file if requested\r\n    if (mergedOptions.includeInfoFile) {\r\n        const infoContent = generateInfoFileContent(processedImages, mergedOptions)\r\n        mainFolder.file('INFO.txt', infoContent)\r\n    }\r\n\r\n    // Generate ZIP\r\n    const zipBlob = await zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: {\r\n            level: 6\r\n        },\r\n        comment: `Created by LemGendary Image Processor - ${now.toISOString()}`,\r\n        platform: 'UNIX'\r\n    })\r\n\r\n    return zipBlob\r\n}\r\n\r\n/**\r\n * Get original files from LemGendImages\r\n * @private\r\n */\r\nasync function getOriginals(images) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        if (image.file && image.file instanceof File) {\r\n            files.push({\r\n                name: image.originalName || image.file.name,\r\n                content: image.file\r\n            })\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Get optimized files from LemGendImages\r\n * @private\r\n */\r\nasync function getOptimizedFiles(images, category) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        // Get outputs from the image\r\n        let outputs = []\r\n\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && typeof image.outputs.get === 'function') {\r\n            // Handle Map-based outputs\r\n            outputs = Array.from(image.outputs.values())\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        // Filter for optimized files (no template or custom category)\r\n        const optimizedOutputs = outputs.filter(output => {\r\n            return !output.template || output.template === 'custom' || output.category === category\r\n        })\r\n\r\n        for (const output of optimizedOutputs) {\r\n            if (output.file && output.file instanceof File) {\r\n                files.push({\r\n                    name: output.file.name || `optimized-${Date.now()}.${getFileExtension(output.file)}`,\r\n                    content: output.file\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Get categorized files from LemGendImages\r\n * @private\r\n */\r\nasync function getCategorizedFiles(images, category) {\r\n    const files = []\r\n\r\n    for (const image of images) {\r\n        // Get outputs from the image\r\n        let outputs = []\r\n\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && typeof image.outputs.get === 'function') {\r\n            // Handle Map-based outputs\r\n            outputs = Array.from(image.outputs.values())\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        // Filter by category\r\n        const categorizedOutputs = outputs.filter(output => {\r\n            const outputCategory = output.template?.category || output.category || ''\r\n            return outputCategory.toLowerCase() === category.toLowerCase()\r\n        })\r\n\r\n        for (const output of categorizedOutputs) {\r\n            if (output.file && output.file instanceof File) {\r\n                files.push({\r\n                    name: output.file.name || `${category}-${Date.now()}.${getFileExtension(output.file)}`,\r\n                    content: output.file\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return files\r\n}\r\n\r\n/**\r\n * Generate info file content\r\n * @private\r\n */\r\nfunction generateInfoFileContent(images, options) {\r\n    const now = new Date()\r\n\r\n    // Collect statistics\r\n    const stats = {\r\n        totalImages: images.length,\r\n        originals: 0,\r\n        optimized: 0,\r\n        web: 0,\r\n        logo: 0,\r\n        favicon: 0,\r\n        social: 0,\r\n        formats: {},\r\n        totalSize: 0\r\n    }\r\n\r\n    // Calculate statistics\r\n    for (const image of images) {\r\n        if (image.file) {\r\n            stats.originals++\r\n            stats.totalSize += image.file.size || 0\r\n        }\r\n\r\n        // Get outputs\r\n        let outputs = []\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (image.outputs && Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        for (const output of outputs) {\r\n            if (output.file) {\r\n                stats.totalSize += output.file.size || 0\r\n\r\n                // Count by category\r\n                const category = output.template?.category || output.category || 'optimized'\r\n                switch (category.toLowerCase()) {\r\n                    case 'web': stats.web++; break\r\n                    case 'logo': stats.logo++; break\r\n                    case 'favicon': stats.favicon++; break\r\n                    case 'social': stats.social++; break\r\n                    default: stats.optimized++\r\n                }\r\n\r\n                // Count by format\r\n                const format = getFileExtension(output.file)\r\n                stats.formats[format] = (stats.formats[format] || 0) + 1\r\n            }\r\n        }\r\n    }\r\n\r\n    // Generate info text\r\n    const infoText = `LEMGENDARY IMAGE EXPORT\r\n===========================\r\n\r\nExport Information\r\n------------------\r\nDate: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}\r\nTool: LemGendary Image Processor\r\nVersion: 2.0.0\r\nExport ID: ${Date.now().toString(36).toUpperCase()}\r\n\r\nOptions Used\r\n------------\r\n${Object.entries(options)\r\n            .filter(([key]) => !['zipName'].includes(key))\r\n            .map(([key, value]) => `${key.padEnd(20)}: ${value}`)\r\n            .join('\\n')}\r\n\r\nStatistics\r\n----------\r\nTotal Images Processed: ${stats.totalImages}\r\nTotal Files in Export: ${stats.originals + stats.optimized + stats.web + stats.logo + stats.favicon + stats.social}\r\n\r\nFile Breakdown:\r\n  Original Images: ${stats.originals}\r\n  Optimized Images: ${stats.optimized}\r\n  Web Images: ${stats.web}\r\n  Logo Images: ${stats.logo}\r\n  Favicon Images: ${stats.favicon}\r\n  Social Media Images: ${stats.social}\r\n\r\nFormat Distribution:\r\n${Object.entries(stats.formats)\r\n            .map(([format, count]) => `  ${format.toUpperCase().padEnd(6)}: ${count} files`)\r\n            .join('\\n')}\r\n\r\nTotal Size: ${formatBytes(stats.totalSize)}\r\n\r\nImage Details\r\n-------------\r\n${images.map((img, index) => {\r\n                const outputs = typeof img.getAllOutputs === 'function' ? img.getAllOutputs() : []\r\n                return `[${index + 1}] ${img.originalName || 'Unnamed'}\r\n  Original: ${formatBytes(img.originalSize || 0)} | ${img.width || '?'}×${img.height || '?'}\r\n  Outputs: ${outputs.length} file(s)\r\n  ${outputs.map(out => `  - ${out.file?.name || 'Unnamed'} (${out.template?.category || 'custom'})`).join('\\n  ')}`\r\n            }).join('\\n\\n')}\r\n\r\nFolder Structure\r\n----------------\r\n${options.createFolders ? `\r\n00_Originals/       - Original uploaded images (${stats.originals > 0 ? stats.originals + ' files' : 'Skipped - empty'})\r\n01_Optimized/       - Custom processed images (${stats.optimized > 0 ? stats.optimized + ' files' : 'Skipped - empty'})\r\n02_Web_Images/      - Web template outputs (${stats.web > 0 ? stats.web + ' files' : 'Skipped - empty'})\r\n03_Logo_Images/     - Logo template outputs (${stats.logo > 0 ? stats.logo + ' files' : 'Skipped - empty'})\r\n04_Favicon_Images/  - Favicon template outputs (${stats.favicon > 0 ? stats.favicon + ' files' : 'Skipped - empty'})\r\n05_Social_Media/    - Social media platform outputs (${stats.social > 0 ? stats.social + ' files' : 'Skipped - empty'})`\r\n            : 'All files in root folder'}\r\n\r\nNotes\r\n-----\r\n• All processing done client-side in browser\r\n• No images uploaded to external servers\r\n• Created with LemGendary Image Processor\r\n• https://github.com/lemgenda/image-lemgendizer`\r\n\r\n    return infoText\r\n}\r\n\r\n/**\r\n * Format bytes to human-readable string\r\n * @private\r\n */\r\nfunction formatBytes(bytes, decimals = 2) {\r\n    if (bytes === 0) return '0 Bytes'\r\n\r\n    const k = 1024\r\n    const dm = decimals < 0 ? 0 : decimals\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\r\n\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]\r\n}\r\n\r\n/**\r\n * Get file extension from filename\r\n * @private\r\n */\r\nfunction getFileExtension(file) {\r\n    if (!file || !file.name) return 'unknown'\r\n\r\n    const parts = file.name.split('.')\r\n    if (parts.length > 1) {\r\n        return parts.pop().toLowerCase()\r\n    }\r\n\r\n    // Try to get from MIME type\r\n    const mimeMap = {\r\n        'image/jpeg': 'jpg',\r\n        'image/jpg': 'jpg',\r\n        'image/png': 'png',\r\n        'image/webp': 'webp',\r\n        'image/gif': 'gif',\r\n        'image/svg+xml': 'svg',\r\n        'image/bmp': 'bmp',\r\n        'image/tiff': 'tiff',\r\n        'image/x-icon': 'ico',\r\n        'image/avif': 'avif'\r\n    }\r\n\r\n    return mimeMap[file.type] || 'unknown'\r\n}\r\n\r\n/**\r\n * Sanitize filename for safe storage\r\n * @param {string} filename - Original filename\r\n * @returns {string} Sanitized filename\r\n */\r\nfunction sanitizeFilename(filename) {\r\n    if (!filename) return 'unnamed-file'\r\n\r\n    return filename\r\n        .replace(/[<>:\"/\\\\|?*]/g, '-')\r\n        .replace(/\\s+/g, '_')\r\n        .replace(/[^\\w.\\-]/g, '')\r\n        .substring(0, 255)\r\n        .trim()\r\n}\r\n\r\n/**\r\n * Create simple ZIP from file list\r\n * @param {Array<File>} files - Files to include in ZIP\r\n * @param {string} zipName - ZIP filename\r\n * @returns {Promise<Blob>} ZIP file as Blob\r\n */\r\nexport async function createSimpleZip(files = [], zipName = 'files') {\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n\r\n    for (const file of files) {\r\n        if (file && file instanceof File) {\r\n            zip.file(sanitizeFilename(file.name), file)\r\n        }\r\n    }\r\n\r\n    return zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: { level: 6 }\r\n    })\r\n}\r\n\r\n/**\r\n * Extract ZIP file\r\n * @param {Blob} zipBlob - ZIP file as Blob\r\n * @returns {Promise<Array>} Array of extracted files\r\n */\r\nexport async function extractZip(zipBlob) {\r\n    if (!(zipBlob instanceof Blob)) {\r\n        throw new Error('Input must be a Blob object')\r\n    }\r\n\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = await JSZip.loadAsync(zipBlob)\r\n    const files = []\r\n\r\n    // Process all files in ZIP\r\n    const filePromises = Object.keys(zip.files).map(async (filename) => {\r\n        const zipEntry = zip.files[filename]\r\n\r\n        if (!zipEntry.dir) {\r\n            try {\r\n                const content = await zipEntry.async('blob')\r\n                const mimeType = getMimeTypeFromExtension(filename)\r\n\r\n                const file = new File([content], filename, {\r\n                    type: mimeType,\r\n                    lastModified: zipEntry.date ? zipEntry.date.getTime() : Date.now()\r\n                })\r\n\r\n                files.push({\r\n                    name: filename,\r\n                    file: file,\r\n                    size: content.size,\r\n                    type: file.type,\r\n                    path: filename.includes('/') ? filename.split('/').slice(0, -1).join('/') : '',\r\n                    lastModified: zipEntry.date\r\n                })\r\n            } catch (error) {\r\n                console.warn(`Failed to extract file ${filename}:`, error)\r\n            }\r\n        }\r\n    })\r\n\r\n    await Promise.all(filePromises)\r\n    return files\r\n}\r\n\r\n/**\r\n * Get MIME type from file extension\r\n * @private\r\n */\r\nfunction getMimeTypeFromExtension(filename) {\r\n    const extension = filename.toLowerCase().split('.').pop()\r\n\r\n    const mimeTypes = {\r\n        // Images\r\n        'jpg': 'image/jpeg',\r\n        'jpeg': 'image/jpeg',\r\n        'png': 'image/png',\r\n        'webp': 'image/webp',\r\n        'gif': 'image/gif',\r\n        'svg': 'image/svg+xml',\r\n        'bmp': 'image/bmp',\r\n        'ico': 'image/x-icon',\r\n        'tiff': 'image/tiff',\r\n        'tif': 'image/tiff',\r\n        'avif': 'image/avif',\r\n\r\n        // Documents\r\n        'pdf': 'application/pdf',\r\n        'txt': 'text/plain',\r\n        'csv': 'text/csv',\r\n        'json': 'application/json',\r\n        'xml': 'application/xml',\r\n\r\n        // Archives\r\n        'zip': 'application/zip',\r\n        'rar': 'application/vnd.rar',\r\n        '7z': 'application/x-7z-compressed',\r\n\r\n        // Default\r\n        '': 'application/octet-stream'\r\n    }\r\n\r\n    return mimeTypes[extension] || 'application/octet-stream'\r\n}\r\n\r\n/**\r\n * Get ZIP file info without extracting\r\n * @param {Blob} zipBlob - ZIP file as Blob\r\n * @returns {Promise<Object>} ZIP information\r\n */\r\nexport async function getZipInfo(zipBlob) {\r\n    if (!(zipBlob instanceof Blob)) {\r\n        throw new Error('Input must be a Blob object')\r\n    }\r\n\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = await JSZip.loadAsync(zipBlob)\r\n\r\n    const files = []\r\n    let totalSize = 0\r\n    let fileCount = 0\r\n    let folderCount = 0\r\n\r\n    Object.keys(zip.files).forEach(filename => {\r\n        const zipEntry = zip.files[filename]\r\n\r\n        if (zipEntry.dir) {\r\n            folderCount++\r\n        } else {\r\n            fileCount++\r\n            const uncompressedSize = zipEntry._data.uncompressedSize || 0\r\n            totalSize += uncompressedSize\r\n\r\n            files.push({\r\n                name: filename,\r\n                size: uncompressedSize,\r\n                compressedSize: zipEntry._data.compressedSize || 0,\r\n                compressed: zipEntry._data.compression !== null,\r\n                directory: false,\r\n                lastModified: zipEntry.date,\r\n                ratio: uncompressedSize > 0\r\n                    ? ((uncompressedSize - zipEntry._data.compressedSize) / uncompressedSize * 100).toFixed(1)\r\n                    : 0\r\n            })\r\n        }\r\n    })\r\n\r\n    return {\r\n        fileCount,\r\n        folderCount,\r\n        totalSize,\r\n        compressedSize: zipBlob.size,\r\n        compressionRatio: totalSize > 0 ? (zipBlob.size / totalSize) : 0,\r\n        files,\r\n        comment: zip.comment || '',\r\n        format: 'ZIP',\r\n        isEncrypted: zip.password !== null,\r\n        timestamp: new Date().toISOString()\r\n    }\r\n}\r\n\r\n/**\r\n * Create ZIP with progress tracking\r\n * @param {Array} processedImages - Processed images\r\n * @param {Object} options - ZIP options\r\n * @param {Function} onProgress - Progress callback (0-1)\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createZipWithProgress(processedImages, options = {}, onProgress = null) {\r\n    // Dynamically load JSZip\r\n    let JSZip\r\n    try {\r\n        JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js')).default\r\n    } catch (error) {\r\n        throw new Error('JSZip library required. Include it via CDN or npm package.')\r\n    }\r\n\r\n    const zip = new JSZip()\r\n    const folderName = options.zipName || `export-${Date.now()}`\r\n    const mainFolder = options.createFolders ? zip.folder(folderName) : zip\r\n\r\n    // Calculate total files for progress\r\n    const totalFiles = calculateTotalFiles(processedImages, options)\r\n    let filesAdded = 0\r\n\r\n    // Add files to ZIP with progress updates\r\n    if (options.includeOriginal) {\r\n        const originals = await getOriginals(processedImages)\r\n        for (const fileData of originals) {\r\n            mainFolder.file(sanitizeFilename(fileData.name), fileData.content)\r\n            filesAdded++\r\n\r\n            if (onProgress) {\r\n                onProgress(filesAdded / totalFiles, `Adding ${fileData.name}`)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add other file categories similarly\r\n    const categories = [\r\n        { name: 'optimized', getter: getOptimizedFiles },\r\n        { name: 'web', getter: (images) => getCategorizedFiles(images, 'web') },\r\n        { name: 'logo', getter: (images) => getCategorizedFiles(images, 'logo') },\r\n        { name: 'favicon', getter: (images) => getCategorizedFiles(images, 'favicon') },\r\n        { name: 'social', getter: (images) => getCategorizedFiles(images, 'social') }\r\n    ]\r\n\r\n    for (const category of categories) {\r\n        if (options[`include${category.name.charAt(0).toUpperCase() + category.name.slice(1)}`]) {\r\n            const files = await category.getter(processedImages)\r\n            const folder = options.createFolders ? mainFolder.folder(getFolderName(category.name)) : mainFolder\r\n\r\n            for (const fileData of files) {\r\n                folder.file(sanitizeFilename(fileData.name), fileData.content)\r\n                filesAdded++\r\n\r\n                if (onProgress) {\r\n                    onProgress(filesAdded / totalFiles, `Adding ${category.name}: ${fileData.name}`)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Generate ZIP with progress\r\n    return zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: { level: 6 }\r\n    }, (metadata) => {\r\n        if (onProgress) {\r\n            const fileProgress = filesAdded / totalFiles\r\n            const zipProgress = metadata.percent / 100\r\n            const overallProgress = fileProgress * 0.5 + zipProgress * 0.5\r\n            onProgress(overallProgress, `Compressing (${metadata.percent.toFixed(1)}%)`)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Calculate total files for progress tracking\r\n * @private\r\n */\r\nfunction calculateTotalFiles(images, options) {\r\n    let count = 0\r\n\r\n    // Count originals\r\n    if (options.includeOriginal) {\r\n        count += images.filter(img => img.file).length\r\n    }\r\n\r\n    // Count optimized/categorized files\r\n    for (const image of images) {\r\n        let outputs = []\r\n        if (typeof image.getAllOutputs === 'function') {\r\n            outputs = image.getAllOutputs()\r\n        } else if (Array.isArray(image.outputs)) {\r\n            outputs = image.outputs\r\n        }\r\n\r\n        for (const output of outputs) {\r\n            const category = output.template?.category || output.category || 'optimized'\r\n            const optionName = `include${category.charAt(0).toUpperCase() + category.slice(1)}`\r\n\r\n            if (options[optionName] !== false) {\r\n                count++\r\n            }\r\n        }\r\n    }\r\n\r\n    return Math.max(count, 1) // Ensure at least 1 for progress calculation\r\n}\r\n\r\n/**\r\n * Get folder name for category\r\n * @private\r\n */\r\nfunction getFolderName(category) {\r\n    const folderMap = {\r\n        'optimized': '01_Optimized',\r\n        'web': '02_Web_Images',\r\n        'logo': '03_Logo_Images',\r\n        'favicon': '04_Favicon_Images',\r\n        'social': '05_Social_Media'\r\n    }\r\n\r\n    return folderMap[category] || category\r\n}\r\n\r\n/**\r\n * Create optimized ZIP structure for custom processing\r\n * @param {Array} processedResults - Results from processing\r\n * @param {Object} options - ZIP options\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createCustomZip(processedResults, options = {}) {\r\n    const images = processedResults\r\n        .filter(result => result.success && result.image)\r\n        .map(result => result.image)\r\n\r\n    const customOptions = {\r\n        ...options,\r\n        includeWebImages: false,\r\n        includeLogoImages: false,\r\n        includeFaviconImages: false,\r\n        includeSocialMedia: false,\r\n        zipName: options.zipName || 'custom-processed'\r\n    }\r\n\r\n    return createLemGendaryZip(images, customOptions)\r\n}\r\n\r\n/**\r\n * Create template-based ZIP structure\r\n * @param {Array} templateResults - Results from template processing\r\n * @param {Object} options - ZIP options\r\n * @returns {Promise<Blob>} ZIP file\r\n */\r\nexport async function createTemplateZip(templateResults, options = {}) {\r\n    const images = templateResults\r\n        .filter(result => result.success && result.image)\r\n        .map(result => result.image)\r\n\r\n    const templateOptions = {\r\n        ...options,\r\n        zipName: options.zipName || 'template-export'\r\n    }\r\n\r\n    return createLemGendaryZip(images, templateOptions)\r\n}\r\n\r\nexport default {\r\n    createLemGendaryZip,\r\n    createSimpleZip,\r\n    extractZip,\r\n    getZipInfo,\r\n    createZipWithProgress,\r\n    createCustomZip,\r\n    createTemplateZip\r\n}","/**\r\n * Image utility functions\r\n * @module utils/imageUtils\r\n */\r\n\r\n/**\r\n * Get image dimensions from File\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Dimensions object\r\n */\r\nexport async function getImageDimensions(file) {\r\n    return new Promise((resolve, reject) => {\r\n        if (!file || !(file instanceof File)) {\r\n            reject(new Error('Invalid file provided'))\r\n            return\r\n        }\r\n\r\n        // Special handling for favicons\r\n        if (file.type === 'image/x-icon' || file.type === 'image/vnd.microsoft.icon') {\r\n            getIcoDimensions(file)\r\n                .then(resolve)\r\n                .catch(() => resolve({ width: 32, height: 32, orientation: 'square', aspectRatio: 1 }))\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const dimensions = {\r\n                width: img.naturalWidth || img.width,\r\n                height: img.naturalHeight || img.height,\r\n                orientation: img.naturalWidth >= img.naturalHeight ? 'landscape' : 'portrait',\r\n                aspectRatio: img.naturalWidth / img.naturalHeight\r\n            }\r\n\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(dimensions)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n\r\n            // For SVG files, try different approach\r\n            if (file.type === 'image/svg+xml') {\r\n                getSVGDimensions(file)\r\n                    .then(resolve)\r\n                    .catch(() => reject(new Error('Failed to load image dimensions')))\r\n            } else {\r\n                reject(new Error('Failed to load image'))\r\n            }\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Get SVG dimensions\r\n * @private\r\n */\r\nasync function getSVGDimensions(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n\r\n        reader.onload = (e) => {\r\n            try {\r\n                const svgText = e.target.result\r\n                const parser = new DOMParser()\r\n                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml')\r\n                const svgElement = svgDoc.documentElement\r\n\r\n                // Check for parsing errors\r\n                if (svgDoc.querySelector('parsererror')) {\r\n                    reject(new Error('Invalid SVG format'))\r\n                    return\r\n                }\r\n\r\n                // Get dimensions\r\n                const width = parseFloat(svgElement.getAttribute('width')) ||\r\n                    svgElement.viewBox?.baseVal?.width || 100\r\n                const height = parseFloat(svgElement.getAttribute('height')) ||\r\n                    svgElement.viewBox?.baseVal?.height || 100\r\n\r\n                resolve({\r\n                    width,\r\n                    height,\r\n                    orientation: width >= height ? 'landscape' : 'portrait',\r\n                    aspectRatio: width / height\r\n                })\r\n            } catch (error) {\r\n                reject(error)\r\n            }\r\n        }\r\n\r\n        reader.onerror = reject\r\n        reader.readAsText(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Get ICO file dimensions (simplified)\r\n * @private\r\n */\r\nasync function getIcoDimensions(file) {\r\n    return new Promise((resolve) => {\r\n        // ICO files can contain multiple sizes, return default for favicons\r\n        resolve({\r\n            width: 32,\r\n            height: 32,\r\n            orientation: 'square',\r\n            aspectRatio: 1\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * Check if image has transparency\r\n * @param {File} file - Image file\r\n * @returns {Promise<boolean>} True if image has transparency\r\n */\r\nexport async function hasTransparency(file) {\r\n    if (!file || (file.type !== 'image/png' && file.type !== 'image/webp')) {\r\n        return false // Only PNG and WebP have meaningful transparency for our purposes\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = img.width\r\n            canvas.height = img.height\r\n            const ctx = canvas.getContext('2d')\r\n            ctx.drawImage(img, 0, 0)\r\n\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\r\n            const data = imageData.data\r\n\r\n            // Check alpha channel\r\n            for (let i = 3; i < data.length; i += 4) {\r\n                if (data[i] < 255) {\r\n                    URL.revokeObjectURL(objectUrl)\r\n                    resolve(true)\r\n                    return\r\n                }\r\n            }\r\n\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(false)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(false)\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Convert File to Data URL\r\n * @param {File} file - File to convert\r\n * @returns {Promise<string>} Data URL\r\n */\r\nexport function fileToDataURL(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n        reader.onload = () => resolve(reader.result)\r\n        reader.onerror = reject\r\n        reader.readAsDataURL(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Convert Data URL to File\r\n * @param {string} dataURL - Data URL\r\n * @param {string} filename - Output filename\r\n * @returns {Promise<File>} File object\r\n */\r\nexport function dataURLtoFile(dataURL, filename) {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            const arr = dataURL.split(',')\r\n            const mime = arr[0].match(/:(.*?);/)[1]\r\n            const bstr = atob(arr[1])\r\n            let n = bstr.length\r\n            const u8arr = new Uint8Array(n)\r\n\r\n            while (n--) {\r\n                u8arr[n] = bstr.charCodeAt(n)\r\n            }\r\n\r\n            resolve(new File([u8arr], filename, { type: mime }))\r\n        } catch (error) {\r\n            reject(error)\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Resize image using canvas\r\n * @param {File} file - Image file\r\n * @param {number} width - Target width\r\n * @param {number} height - Target height\r\n * @param {string} format - Output format\r\n * @param {number} quality - Quality (0-1)\r\n * @returns {Promise<File>} Resized image file\r\n */\r\nexport async function resizeImage(file, width, height, format = 'webp', quality = 0.8) {\r\n    return new Promise((resolve, reject) => {\r\n        // Special handling for favicon format\r\n        if (format.toLowerCase() === 'ico') {\r\n            // Create PNG first, then convert to ICO (simplified approach)\r\n            resizeImage(file, width, height, 'png', quality)\r\n                .then(pngFile => {\r\n                    // For now, return PNG and warn about ICO limitation\r\n                    console.warn('ICO format creation limited in browser. Using PNG instead.')\r\n                    resolve(pngFile)\r\n                })\r\n                .catch(reject)\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Fill background for JPEG\r\n            if (format === 'jpg' || format === 'jpeg') {\r\n                ctx.fillStyle = '#ffffff'\r\n                ctx.fillRect(0, 0, width, height)\r\n            }\r\n\r\n            ctx.drawImage(img, 0, 0, width, height)\r\n\r\n            // Determine MIME type\r\n            let mimeType\r\n            switch (format.toLowerCase()) {\r\n                case 'jpg':\r\n                case 'jpeg':\r\n                    mimeType = 'image/jpeg'\r\n                    break\r\n                case 'png':\r\n                    mimeType = 'image/png'\r\n                    break\r\n                case 'webp':\r\n                    mimeType = 'image/webp'\r\n                    break\r\n                case 'avif':\r\n                    mimeType = 'image/avif'\r\n                    break\r\n                case 'svg':\r\n                    mimeType = 'image/svg+xml'\r\n                    break\r\n                default:\r\n                    mimeType = 'image/webp'\r\n            }\r\n\r\n            canvas.toBlob(\r\n                (blob) => {\r\n                    URL.revokeObjectURL(objectUrl)\r\n\r\n                    if (!blob) {\r\n                        reject(new Error('Failed to create blob'))\r\n                        return\r\n                    }\r\n\r\n                    const extension = format.toLowerCase()\r\n                    const originalName = file.name.replace(/\\.[^/.]+$/, '')\r\n                    const newName = `${originalName}-${width}x${height}.${extension}`\r\n\r\n                    resolve(new File([blob], newName, { type: mimeType }))\r\n                },\r\n                mimeType,\r\n                quality\r\n            )\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to load image'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Crop image using canvas\r\n * @param {File} file - Image file\r\n * @param {number} x - X offset\r\n * @param {number} y - Y offset\r\n * @param {number} width - Crop width\r\n * @param {number} height - Crop height\r\n * @param {string} format - Output format\r\n * @param {number} quality - Quality (0-1)\r\n * @returns {Promise<File>} Cropped image file\r\n */\r\nexport async function cropImage(file, x, y, width, height, format = 'webp', quality = 0.8) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Fill background for JPEG\r\n            if (format === 'jpg' || format === 'jpeg') {\r\n                ctx.fillStyle = '#ffffff'\r\n                ctx.fillRect(0, 0, width, height)\r\n            }\r\n\r\n            ctx.drawImage(img, x, y, width, height, 0, 0, width, height)\r\n\r\n            // Determine MIME type\r\n            let mimeType\r\n            switch (format.toLowerCase()) {\r\n                case 'jpg':\r\n                case 'jpeg':\r\n                    mimeType = 'image/jpeg'\r\n                    break\r\n                case 'png':\r\n                    mimeType = 'image/png'\r\n                    break\r\n                case 'webp':\r\n                    mimeType = 'image/webp'\r\n                    break\r\n                default:\r\n                    mimeType = 'image/webp'\r\n            }\r\n\r\n            canvas.toBlob(\r\n                (blob) => {\r\n                    URL.revokeObjectURL(objectUrl)\r\n\r\n                    if (!blob) {\r\n                        reject(new Error('Failed to create blob'))\r\n                        return\r\n                    }\r\n\r\n                    const extension = format.toLowerCase()\r\n                    const originalName = file.name.replace(/\\.[^/.]+$/, '')\r\n                    const newName = `${originalName}-crop-${width}x${height}.${extension}`\r\n\r\n                    resolve(new File([blob], newName, { type: mimeType }))\r\n                },\r\n                mimeType,\r\n                quality\r\n            )\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to load image'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Calculate new dimensions maintaining aspect ratio\r\n * @param {number} originalWidth - Original width\r\n * @param {number} originalHeight - Original height\r\n * @param {number} targetSize - Target size (width or height)\r\n * @param {string} mode - 'width', 'height', or 'auto'\r\n * @returns {Object} New dimensions\r\n */\r\nexport function calculateAspectRatioFit(originalWidth, originalHeight, targetSize, mode = 'auto') {\r\n    if (mode === 'width') {\r\n        const newWidth = targetSize\r\n        const newHeight = Math.round((originalHeight / originalWidth) * targetSize)\r\n        return { width: newWidth, height: newHeight }\r\n    } else if (mode === 'height') {\r\n        const newHeight = targetSize\r\n        const newWidth = Math.round((originalWidth / originalHeight) * targetSize)\r\n        return { width: newWidth, height: newHeight }\r\n    } else {\r\n        // Auto mode: portrait uses height, landscape uses width\r\n        if (originalWidth >= originalHeight) {\r\n            const newWidth = targetSize\r\n            const newHeight = Math.round((originalHeight / originalWidth) * targetSize)\r\n            return { width: newWidth, height: newHeight }\r\n        } else {\r\n            const newHeight = targetSize\r\n            const newWidth = Math.round((originalWidth / originalHeight) * targetSize)\r\n            return { width: newWidth, height: newHeight }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Format file size for display\r\n * @param {number} bytes - File size in bytes\r\n * @param {number} decimals - Decimal places\r\n * @returns {string} Formatted size\r\n */\r\nexport function formatFileSize(bytes, decimals = 2) {\r\n    if (bytes === 0) return '0 Bytes'\r\n\r\n    const k = 1024\r\n    const dm = decimals < 0 ? 0 : decimals\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\r\n\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\r\n\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]\r\n}\r\n\r\n/**\r\n * Get file extension from filename or MIME type\r\n * @param {File|string} fileOrName - File object or filename\r\n * @returns {string} File extension\r\n */\r\nexport function getFileExtension(fileOrName) {\r\n    if (fileOrName instanceof File) {\r\n        // Try from name first\r\n        const nameExt = fileOrName.name.split('.').pop().toLowerCase()\r\n        if (nameExt && nameExt.length <= 4) {\r\n            return nameExt\r\n        }\r\n\r\n        // Fall back to MIME type\r\n        const mimeExt = {\r\n            'image/jpeg': 'jpg',\r\n            'image/jpg': 'jpg',\r\n            'image/png': 'png',\r\n            'image/webp': 'webp',\r\n            'image/gif': 'gif',\r\n            'image/svg+xml': 'svg',\r\n            'image/bmp': 'bmp',\r\n            'image/tiff': 'tiff',\r\n            'image/avif': 'avif',\r\n            'image/x-icon': 'ico',\r\n            'image/vnd.microsoft.icon': 'ico'\r\n        }[fileOrName.type]\r\n\r\n        return mimeExt || 'unknown'\r\n    }\r\n\r\n    // String input\r\n    const name = typeof fileOrName === 'string' ? fileOrName : ''\r\n    const ext = name.split('.').pop().toLowerCase()\r\n    return ext && ext.length <= 4 ? ext : 'unknown'\r\n}\r\n\r\n/**\r\n * Validate image file\r\n * @param {File} file - File to validate\r\n * @returns {Object} Validation result\r\n */\r\nexport function validateImageFile(file) {\r\n    const errors = []\r\n    const warnings = []\r\n\r\n    // Check if it's a File object\r\n    if (!(file instanceof File)) {\r\n        errors.push('Not a valid File object')\r\n        return { valid: false, errors, warnings }\r\n    }\r\n\r\n    // Check file type\r\n    const validTypes = [\r\n        'image/jpeg',\r\n        'image/jpg',\r\n        'image/png',\r\n        'image/webp',\r\n        'image/gif',\r\n        'image/svg+xml',\r\n        'image/bmp',\r\n        'image/tiff',\r\n        'image/avif',\r\n        'image/x-icon',\r\n        'image/vnd.microsoft.icon'\r\n    ]\r\n\r\n    if (!validTypes.includes(file.type)) {\r\n        errors.push(`Unsupported file type: ${file.type}`)\r\n    }\r\n\r\n    // Check file size\r\n    const maxSize = 50 * 1024 * 1024 // 50MB\r\n    if (file.size > maxSize) {\r\n        errors.push(`File too large: ${formatFileSize(file.size)} (max: ${formatFileSize(maxSize)})`)\r\n    } else if (file.size > 10 * 1024 * 1024) { // 10MB\r\n        warnings.push(`Large file: ${formatFileSize(file.size)} - processing may be slow`)\r\n    }\r\n\r\n    // Check filename\r\n    const invalidChars = /[<>:\"/\\\\|?*]/\r\n    if (invalidChars.test(file.name)) {\r\n        warnings.push('Filename contains invalid characters')\r\n    }\r\n\r\n    return {\r\n        valid: errors.length === 0,\r\n        errors,\r\n        warnings\r\n    }\r\n}\r\n\r\n/**\r\n * Create image thumbnail\r\n * @param {File} file - Image file\r\n * @param {number} maxSize - Maximum thumbnail dimension\r\n * @returns {Promise<string>} Thumbnail as Data URL\r\n */\r\nexport async function createThumbnail(file, maxSize = 200) {\r\n    return new Promise((resolve, reject) => {\r\n        // Special handling for favicons\r\n        if (file.type === 'image/x-icon' || file.type === 'image/vnd.microsoft.icon') {\r\n            // Use a default favicon icon as thumbnail\r\n            resolve('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iIzM4ODJlZiIvPjxjaXJjbGUgY3g9IjEwMCIgY3k9IjEwMCIgcj0iNjAiIGZpbGw9IiNmZmYiLz48Y2lyY2xlIGN4PSIxMDAiIGN5PSIxMDAiIHI9IjQwIiBmaWxsPSIjMzg4MmVmIi8+PC9zdmc+')\r\n            return\r\n        }\r\n\r\n        const img = new Image()\r\n        const objectUrl = URL.createObjectURL(file)\r\n\r\n        img.onload = () => {\r\n            // Calculate thumbnail dimensions\r\n            let width, height\r\n            if (img.width > img.height) {\r\n                width = maxSize\r\n                height = Math.round((img.height / img.width) * maxSize)\r\n            } else {\r\n                height = maxSize\r\n                width = Math.round((img.width / img.height) * maxSize)\r\n            }\r\n\r\n            // Create canvas for thumbnail\r\n            const canvas = document.createElement('canvas')\r\n            canvas.width = width\r\n            canvas.height = height\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            // Draw image\r\n            ctx.drawImage(img, 0, 0, width, height)\r\n\r\n            // Convert to Data URL\r\n            const thumbnail = canvas.toDataURL('image/jpeg', 0.7)\r\n\r\n            // Clean up\r\n            URL.revokeObjectURL(objectUrl)\r\n            resolve(thumbnail)\r\n        }\r\n\r\n        img.onerror = () => {\r\n            URL.revokeObjectURL(objectUrl)\r\n            reject(new Error('Failed to create thumbnail'))\r\n        }\r\n\r\n        img.src = objectUrl\r\n    })\r\n}\r\n\r\n/**\r\n * Batch process images with progress tracking\r\n * @param {Array<File>} files - Image files\r\n * @param {Function} processor - Processing function\r\n * @param {Function} onProgress - Progress callback\r\n * @returns {Promise<Array>} Processed results\r\n */\r\nexport async function batchProcess(files, processor, onProgress) {\r\n    const results = []\r\n    const total = files.length\r\n\r\n    for (let i = 0; i < files.length; i++) {\r\n        try {\r\n            const result = await processor(files[i], i)\r\n            results.push(result)\r\n\r\n            if (onProgress) {\r\n                onProgress((i + 1) / total, i + 1, total)\r\n            }\r\n        } catch (error) {\r\n            console.error(`Error processing file ${i + 1}:`, error)\r\n            results.push({ error: error.message, file: files[i] })\r\n        }\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n/**\r\n * Analyze image for optimization potential\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Optimization analysis\r\n */\r\nexport async function analyzeForOptimization(file) {\r\n    const dimensions = await getImageDimensions(file)\r\n    const transparency = await hasTransparency(file)\r\n\r\n    const analysis = {\r\n        dimensions,\r\n        transparency,\r\n        fileSize: file.size,\r\n        mimeType: file.type,\r\n        extension: getFileExtension(file),\r\n        optimizationScore: 0,\r\n        recommendations: []\r\n    }\r\n\r\n    // Calculate optimization score (0-100)\r\n    let score = 0\r\n\r\n    // Size-based scoring\r\n    if (file.size > 5 * 1024 * 1024) {\r\n        score += 40 // Large files have high optimization potential\r\n        analysis.recommendations.push('File is very large - high optimization potential')\r\n    } else if (file.size > 1 * 1024 * 1024) {\r\n        score += 20\r\n    } else if (file.size > 100 * 1024) {\r\n        score += 10\r\n    }\r\n\r\n    // Dimension-based scoring\r\n    const megapixels = (dimensions.width * dimensions.height) / 1000000\r\n    if (megapixels > 16) {\r\n        score += 30\r\n        analysis.recommendations.push('Very high resolution - consider resizing')\r\n    } else if (megapixels > 4) {\r\n        score += 15\r\n    }\r\n\r\n    // Format-based scoring\r\n    const modernFormats = ['webp', 'avif', 'svg']\r\n    const currentFormat = getFileExtension(file)\r\n    if (!modernFormats.includes(currentFormat)) {\r\n        score += 20\r\n        analysis.recommendations.push(`Consider converting from ${currentFormat} to modern format`)\r\n    }\r\n\r\n    // Transparency consideration\r\n    if (transparency && currentFormat === 'jpg') {\r\n        score += 10\r\n        analysis.recommendations.push('JPEG with transparency - convert to PNG or WebP')\r\n    }\r\n\r\n    analysis.optimizationScore = Math.min(100, score)\r\n    analysis.optimizationLevel = score > 50 ? 'high' : score > 25 ? 'medium' : 'low'\r\n\r\n    return analysis\r\n}\r\n\r\n/**\r\n * Get optimization presets for common use cases\r\n * @param {string} useCase - Use case identifier\r\n * @returns {Object} Optimization preset\r\n */\r\nexport function getOptimizationPreset(useCase) {\r\n    const presets = {\r\n        'web-high': {\r\n            quality: 85,\r\n            format: 'auto',\r\n            maxDisplayWidth: 1920,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: true,\r\n            description: 'High quality web images'\r\n        },\r\n        'web-balanced': {\r\n            quality: 80,\r\n            format: 'auto',\r\n            maxDisplayWidth: 1200,\r\n            compressionMode: 'adaptive',\r\n            stripMetadata: true,\r\n            description: 'Balanced web images'\r\n        },\r\n        'web-aggressive': {\r\n            quality: 70,\r\n            format: 'webp',\r\n            maxDisplayWidth: 800,\r\n            compressionMode: 'aggressive',\r\n            stripMetadata: true,\r\n            description: 'Aggressive web optimization'\r\n        },\r\n        'social-media': {\r\n            quality: 90,\r\n            format: 'jpg',\r\n            maxDisplayWidth: 1080,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: false, // Keep metadata for social\r\n            description: 'Social media images'\r\n        },\r\n        'ecommerce': {\r\n            quality: 92,\r\n            format: 'webp',\r\n            maxDisplayWidth: 1200,\r\n            compressionMode: 'balanced',\r\n            stripMetadata: true,\r\n            preserveTransparency: true,\r\n            description: 'E-commerce product images'\r\n        },\r\n        'favicon': {\r\n            quality: 100,\r\n            format: 'ico',\r\n            compressionMode: 'balanced',\r\n            icoSizes: [16, 32, 48, 64],\r\n            description: 'Favicon generation'\r\n        },\r\n        'print-ready': {\r\n            quality: 100,\r\n            format: 'png',\r\n            compressionMode: 'balanced',\r\n            lossless: true,\r\n            stripMetadata: false,\r\n            description: 'Print-ready images'\r\n        },\r\n        'mobile-optimized': {\r\n            quality: 75,\r\n            format: 'webp',\r\n            maxDisplayWidth: 800,\r\n            compressionMode: 'aggressive',\r\n            stripMetadata: true,\r\n            description: 'Mobile-optimized images'\r\n        }\r\n    }\r\n\r\n    return presets[useCase] || presets['web-balanced']\r\n}\r\n\r\n/**\r\n * Calculate estimated optimization savings\r\n * @param {number} originalSize - Original file size in bytes\r\n * @param {Object} optimizationSettings - Optimization settings\r\n * @returns {Object} Estimated savings\r\n */\r\nexport function calculateOptimizationSavings(originalSize, optimizationSettings) {\r\n    const { format, quality, maxDisplayWidth } = optimizationSettings\r\n\r\n    let estimatedSize = originalSize\r\n    let reductionFactors = []\r\n\r\n    // Format reduction\r\n    switch (format) {\r\n        case 'webp':\r\n            estimatedSize *= 0.7\r\n            reductionFactors.push('WebP format: 30% reduction')\r\n            break\r\n        case 'avif':\r\n            estimatedSize *= 0.6\r\n            reductionFactors.push('AVIF format: 40% reduction')\r\n            break\r\n        case 'jpg':\r\n            estimatedSize *= 0.8\r\n            reductionFactors.push('JPEG format: 20% reduction')\r\n            break\r\n        case 'png':\r\n            estimatedSize *= 0.9\r\n            reductionFactors.push('PNG format: 10% reduction')\r\n            break\r\n        case 'svg':\r\n            estimatedSize *= 0.3\r\n            reductionFactors.push('SVG format: 70% reduction')\r\n            break\r\n        default:\r\n            estimatedSize *= 0.75\r\n            reductionFactors.push('Auto format selection: ~25% reduction')\r\n    }\r\n\r\n    // Quality reduction\r\n    const qualityFactor = quality / 100\r\n    estimatedSize *= qualityFactor\r\n    reductionFactors.push(`Quality ${quality}%: ${Math.round((1 - qualityFactor) * 100)}% reduction`)\r\n\r\n    // Display width reduction (if specified)\r\n    if (maxDisplayWidth) {\r\n        // Assume typical reduction for web display\r\n        estimatedSize *= 0.85\r\n        reductionFactors.push(`Max width ${maxDisplayWidth}px: ~15% reduction`)\r\n    }\r\n\r\n    const savings = originalSize - estimatedSize\r\n    const savingsPercent = (savings / originalSize) * 100\r\n\r\n    return {\r\n        originalSize,\r\n        estimatedSize: Math.round(estimatedSize),\r\n        savings: Math.round(savings),\r\n        savingsPercent: Math.round(savingsPercent * 10) / 10,\r\n        reductionFactors,\r\n        readable: {\r\n            original: formatFileSize(originalSize),\r\n            estimated: formatFileSize(Math.round(estimatedSize)),\r\n            savings: formatFileSize(Math.round(savings)),\r\n            savingsPercent: `${Math.round(savingsPercent * 10) / 10}%`\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Create optimization preview\r\n * @param {File} file - Image file\r\n * @param {Object} optimizationSettings - Optimization settings\r\n * @returns {Promise<string>} Data URL of optimized preview\r\n */\r\nexport async function createOptimizationPreview(file, optimizationSettings) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image()\r\n\r\n        img.onload = () => {\r\n            try {\r\n                const canvas = document.createElement('canvas')\r\n                const ctx = canvas.getContext('2d')\r\n\r\n                // Calculate preview dimensions (max 400px for preview)\r\n                const maxPreviewSize = 400\r\n                let width = img.width\r\n                let height = img.height\r\n\r\n                if (width > maxPreviewSize || height > maxPreviewSize) {\r\n                    if (width >= height) {\r\n                        width = maxPreviewSize\r\n                        height = Math.round((img.height / img.width) * maxPreviewSize)\r\n                    } else {\r\n                        height = maxPreviewSize\r\n                        width = Math.round((img.width / img.height) * maxPreviewSize)\r\n                    }\r\n                }\r\n\r\n                canvas.width = width\r\n                canvas.height = height\r\n\r\n                // Draw image\r\n                ctx.drawImage(img, 0, 0, width, height)\r\n\r\n                // Create preview with reduced quality\r\n                const previewQuality = Math.min(0.7, optimizationSettings.quality / 100 * 0.8)\r\n                const previewDataURL = canvas.toDataURL('image/jpeg', previewQuality)\r\n\r\n                resolve(previewDataURL)\r\n            } catch (error) {\r\n                reject(error)\r\n            }\r\n        }\r\n\r\n        img.onerror = reject\r\n        img.src = URL.createObjectURL(file)\r\n    })\r\n}\r\n\r\n/**\r\n * Generate optimization comparison\r\n * @param {File} originalFile - Original image file\r\n * @param {File} optimizedFile - Optimized image file\r\n * @returns {Promise<Object>} Comparison data\r\n */\r\nexport async function generateOptimizationComparison(originalFile, optimizedFile) {\r\n    const originalSize = originalFile.size\r\n    const optimizedSize = optimizedFile.size\r\n    const savings = originalSize - optimizedSize\r\n    const savingsPercent = (savings / originalSize) * 100\r\n\r\n    // Get thumbnails for visual comparison\r\n    const originalThumbnail = await createThumbnail(originalFile, 300)\r\n    const optimizedThumbnail = await createThumbnail(optimizedFile, 300)\r\n\r\n    return {\r\n        original: {\r\n            size: originalSize,\r\n            sizeFormatted: formatFileSize(originalSize),\r\n            thumbnail: originalThumbnail\r\n        },\r\n        optimized: {\r\n            size: optimizedSize,\r\n            sizeFormatted: formatFileSize(optimizedSize),\r\n            thumbnail: optimizedThumbnail\r\n        },\r\n        savings: {\r\n            bytes: savings,\r\n            percent: Math.round(savingsPercent * 10) / 10,\r\n            formatted: formatFileSize(savings),\r\n            compressionRatio: (originalSize / optimizedSize).toFixed(2)\r\n        },\r\n        comparison: savingsPercent > 0 ?\r\n            `Saved ${formatFileSize(savings)} (${Math.round(savingsPercent)}%)` :\r\n            'No savings achieved'\r\n    }\r\n}\r\n\r\n/**\r\n * Check if image format needs conversion for web\r\n * @param {File} file - Image file\r\n * @returns {boolean} True if format conversion recommended\r\n */\r\nexport function needsFormatConversion(file) {\r\n    const extension = getFileExtension(file)\r\n    const modernFormats = ['webp', 'avif', 'svg']\r\n    return !modernFormats.includes(extension)\r\n}\r\n\r\n/**\r\n * Get recommended format for web\r\n * @param {File} file - Image file\r\n * @returns {string} Recommended format\r\n */\r\nexport function getRecommendedFormat(file) {\r\n    const extension = getFileExtension(file)\r\n\r\n    if (extension === 'svg') return 'svg'\r\n    if (extension === 'ico') return 'ico'\r\n\r\n    // Check if image has transparency\r\n    if (file.type === 'image/png' || file.type === 'image/webp') {\r\n        return 'webp' // WebP supports transparency\r\n    }\r\n\r\n    // For large images, recommend AVIF\r\n    if (file.size > 2 * 1024 * 1024) {\r\n        return 'avif'\r\n    }\r\n\r\n    return 'webp' // Default to WebP for good balance\r\n}\r\n\r\n/**\r\n * Get optimization quick stats\r\n * @param {File} file - Image file\r\n * @returns {Promise<Object>} Quick optimization stats\r\n */\r\nexport async function getOptimizationStats(file) {\r\n    const analysis = await analyzeForOptimization(file)\r\n    const recommendedFormat = getRecommendedFormat(file)\r\n    const savings = calculateOptimizationSavings(file.size, {\r\n        format: recommendedFormat,\r\n        quality: 85,\r\n        maxDisplayWidth: 1920\r\n    })\r\n\r\n    return {\r\n        analysis,\r\n        recommendedFormat,\r\n        estimatedSavings: savings,\r\n        needsOptimization: analysis.optimizationScore > 30,\r\n        priority: analysis.optimizationLevel\r\n    }\r\n}\r\n\r\nexport default {\r\n    getImageDimensions,\r\n    hasTransparency,\r\n    fileToDataURL,\r\n    dataURLtoFile,\r\n    resizeImage,\r\n    cropImage,\r\n    calculateAspectRatioFit,\r\n    formatFileSize,\r\n    getFileExtension,\r\n    validateImageFile,\r\n    createThumbnail,\r\n    batchProcess,\r\n    analyzeForOptimization,\r\n    getOptimizationPreset,\r\n    calculateOptimizationSavings,\r\n    createOptimizationPreview,\r\n    generateOptimizationComparison,\r\n    needsFormatConversion,\r\n    getRecommendedFormat,\r\n    getOptimizationStats\r\n}"],"names":["createLemGendaryZip","processedImages","options","mergedOptions","JSZip","zip","now","timestamp","folderName","mainFolder","folderConfigs","getOriginals","getOptimizedFiles","getCategorizedFiles","config","folder","fileData","fileName","sanitizeFilename","infoContent","generateInfoFileContent","images","files","image","category","outputs","optimizedOutputs","output","getFileExtension","categorizedOutputs","stats","format","key","value","count","formatBytes","img","index","out","bytes","decimals","k","dm","sizes","i","file","parts","filename","createSimpleZip","zipName","extractZip","zipBlob","filePromises","zipEntry","content","mimeType","getMimeTypeFromExtension","error","extension","getZipInfo","totalSize","fileCount","folderCount","uncompressedSize","createZipWithProgress","onProgress","totalFiles","calculateTotalFiles","filesAdded","originals","categories","getFolderName","metadata","fileProgress","zipProgress","overallProgress","optionName","createCustomZip","processedResults","result","customOptions","createTemplateZip","templateResults","templateOptions","zipUtils","getImageDimensions","resolve","reject","getIcoDimensions","objectUrl","dimensions","getSVGDimensions","reader","e","svgText","svgDoc","svgElement","width","height","hasTransparency","canvas","ctx","data","fileToDataURL","dataURLtoFile","dataURL","arr","mime","bstr","n","u8arr","resizeImage","quality","pngFile","blob","newName","cropImage","x","y","calculateAspectRatioFit","originalWidth","originalHeight","targetSize","mode","newWidth","newHeight","formatFileSize","fileOrName","nameExt","ext","validateImageFile","errors","warnings","maxSize","createThumbnail","thumbnail","batchProcess","processor","results","total","analyzeForOptimization","transparency","analysis","score","megapixels","modernFormats","currentFormat","getOptimizationPreset","useCase","presets","calculateOptimizationSavings","originalSize","optimizationSettings","maxDisplayWidth","estimatedSize","reductionFactors","qualityFactor","savings","savingsPercent","createOptimizationPreview","maxPreviewSize","previewQuality","previewDataURL","generateOptimizationComparison","originalFile","optimizedFile","optimizedSize","originalThumbnail","optimizedThumbnail","needsFormatConversion","getRecommendedFormat","getOptimizationStats","recommendedFormat","imageUtils"],"mappings":"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"}