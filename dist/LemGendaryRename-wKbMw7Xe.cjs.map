{"version":3,"file":"LemGendaryRename-wKbMw7Xe.cjs","sources":["../src/processors/LemGendaryResize.js","../src/processors/LemGendaryCrop.js","../src/processors/LemGendaryOptimize.js","../src/processors/LemGendaryRename.js"],"sourcesContent":["/**\r\n * LemGendaryResize™ - Intelligent resize processor with enhanced validation\r\n * @class\r\n * @description Resizes each image based on its longest dimension.\r\n * Portrait images: height gets set to target dimension.\r\n * Landscape images: width gets set to target dimension.\r\n * Square images: both dimensions set to target dimension.\r\n * Always maintains aspect ratio by default.\r\n */\r\nexport class LemGendaryResize {\r\n    /**\r\n     * Create a LemGendaryResize processor\r\n     * @param {Object} options - Resize options\r\n     * @param {number} options.dimension - Target dimension for longest side of each image\r\n     * @param {boolean} options.upscale - Allow upscaling (default: false)\r\n     * @param {string} options.algorithm - Resize algorithm ('lanczos3', 'bilinear', 'nearest', 'cubic', 'mitchell')\r\n     * @param {boolean} options.forceSquare - Force square output (for favicons/icons)\r\n     * @param {boolean} options.preserveAspectRatio - Maintain aspect ratio (default: true)\r\n     * @param {number} options.maxDimension - Maximum dimension limit\r\n     * @param {boolean} options.skipSvg - Skip SVG files (default: true, as they're vector)\r\n     * @param {string} options.mode - Resize mode: 'longest', 'width', 'height', 'auto'\r\n     */\r\n    constructor(options = {}) {\r\n        this.dimension = options.dimension || 1080\r\n        this.upscale = options.upscale || false\r\n        this.algorithm = options.algorithm || 'lanczos3'\r\n        this.forceSquare = options.forceSquare || false\r\n        this.preserveAspectRatio = options.preserveAspectRatio !== false\r\n        this.maxDimension = options.maxDimension || 10000\r\n        this.skipSvg = options.skipSvg !== false // Skip SVG by default\r\n        this.mode = options.mode || 'longest' // 'longest', 'width', 'height', 'auto'\r\n        this.name = 'LemGendaryResize'\r\n        this.version = '2.0.0' // Updated version for enhanced validation\r\n    }\r\n\r\n    /**\r\n     * Validate processor options using enhanced validation system\r\n     * @private\r\n     */\r\n    _validateOptions = () => {\r\n        const errors = []\r\n        const warnings = []\r\n\r\n        // Validate dimension\r\n        if (typeof this.dimension !== 'number' || this.dimension <= 0) {\r\n            errors.push({\r\n                code: 'INVALID_DIMENSION',\r\n                message: 'Dimension must be a positive number',\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        if (this.dimension > this.maxDimension) {\r\n            errors.push({\r\n                code: 'DIMENSION_EXCEEDS_MAX',\r\n                message: `Dimension exceeds maximum allowed value of ${this.maxDimension}`,\r\n                severity: 'error',\r\n                suggestion: `Reduce dimension to ${this.maxDimension} or less`\r\n            })\r\n        }\r\n\r\n        if (this.dimension < 10) {\r\n            warnings.push({\r\n                code: 'VERY_SMALL_DIMENSION',\r\n                message: `Very small target dimension (${this.dimension}px)`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider at least 100px for usable images'\r\n            })\r\n        }\r\n\r\n        if (this.dimension > 4000) {\r\n            warnings.push({\r\n                code: 'VERY_LARGE_DIMENSION',\r\n                message: `Very large target dimension (${this.dimension}px)`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider 1920px or less for web images'\r\n            })\r\n        }\r\n\r\n        // Validate algorithm\r\n        const validAlgorithms = ['lanczos3', 'bilinear', 'nearest', 'cubic', 'mitchell']\r\n        if (!validAlgorithms.includes(this.algorithm)) {\r\n            errors.push({\r\n                code: 'INVALID_ALGORITHM',\r\n                message: `Algorithm must be one of: ${validAlgorithms.join(', ')}`,\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Validate mode\r\n        const validModes = ['longest', 'width', 'height', 'auto']\r\n        if (!validModes.includes(this.mode)) {\r\n            errors.push({\r\n                code: 'INVALID_MODE',\r\n                message: `Mode must be one of: ${validModes.join(', ')}`,\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Round dimension if not integer\r\n        if (!Number.isInteger(this.dimension)) {\r\n            warnings.push({\r\n                code: 'NON_INTEGER_DIMENSION',\r\n                message: 'Dimension should be an integer for best results',\r\n                severity: 'info'\r\n            })\r\n            this.dimension = Math.round(this.dimension)\r\n        }\r\n\r\n        // Check for potential issues\r\n        if (this.forceSquare && !this.preserveAspectRatio) {\r\n            warnings.push({\r\n                code: 'FORCE_SQUARE_NO_ASPECT',\r\n                message: 'Force square without preserving aspect ratio may cause issues',\r\n                severity: 'warning',\r\n                suggestion: 'Consider enabling preserveAspectRatio for forceSquare'\r\n            })\r\n        }\r\n\r\n        // Throw errors if any\r\n        if (errors.length > 0) {\r\n            const errorMessages = errors.map(e => e.message).join(', ')\r\n            throw new Error(`Invalid resize options: ${errorMessages}`)\r\n        }\r\n\r\n        // Log warnings\r\n        if (warnings.length > 0) {\r\n            console.warn('Resize warnings:', warnings.map(w => w.message))\r\n        }\r\n\r\n        return { errors, warnings }\r\n    }\r\n\r\n    /**\r\n     * Validate if image can be processed\r\n     * @private\r\n     */\r\n    _validateImage = (lemGendImage) => {\r\n        const errors = []\r\n        const warnings = []\r\n\r\n        if (!lemGendImage) {\r\n            errors.push('No image provided')\r\n            return { canProcess: false, errors, warnings }\r\n        }\r\n\r\n        if (!lemGendImage.width || !lemGendImage.height) {\r\n            errors.push('Image missing dimensions')\r\n            return { canProcess: false, errors, warnings }\r\n        }\r\n\r\n        // Check for SVG\r\n        if (lemGendImage.type === 'image/svg+xml') {\r\n            if (this.skipSvg) {\r\n                warnings.push({\r\n                    code: 'SVG_SKIPPED',\r\n                    message: 'SVG files are vector-based and will not be raster-resized',\r\n                    severity: 'info',\r\n                    suggestion: 'Consider converting to raster format first or disable skipSvg'\r\n                })\r\n                return { canProcess: false, errors, warnings }\r\n            } else {\r\n                warnings.push({\r\n                    code: 'SVG_RASTERIZED',\r\n                    message: 'SVG will be rasterized before resizing (quality loss possible)',\r\n                    severity: 'warning'\r\n                })\r\n            }\r\n        }\r\n\r\n        // Check for ICO/favicon\r\n        if (lemGendImage.type.includes('icon')) {\r\n            warnings.push({\r\n                code: 'FAVICON_RESIZE',\r\n                message: 'ICO files contain multiple images; resizing may affect all frames',\r\n                severity: 'info'\r\n            })\r\n        }\r\n\r\n        // Check for extreme aspect ratios\r\n        const aspectRatio = lemGendImage.width / lemGendImage.height\r\n        if (aspectRatio > 10 || aspectRatio < 0.1) {\r\n            warnings.push({\r\n                code: 'EXTREME_ASPECT_RATIO',\r\n                message: `Extreme aspect ratio: ${aspectRatio.toFixed(2)}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider cropping before resizing'\r\n            })\r\n        }\r\n\r\n        // Check for very small images\r\n        if (lemGendImage.width < 50 || lemGendImage.height < 50) {\r\n            warnings.push({\r\n                code: 'VERY_SMALL_SOURCE',\r\n                message: `Very small source image: ${lemGendImage.width}x${lemGendImage.height}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider using larger source image'\r\n            })\r\n        }\r\n\r\n        // Check for very large images\r\n        const megapixels = (lemGendImage.width * lemGendImage.height) / 1000000\r\n        if (megapixels > 16) {\r\n            warnings.push({\r\n                code: 'VERY_LARGE_SOURCE',\r\n                message: `Very large source image: ${megapixels.toFixed(1)}MP`,\r\n                severity: 'info',\r\n                suggestion: 'Resizing may take longer to process'\r\n            })\r\n        }\r\n\r\n        return {\r\n            canProcess: true,\r\n            errors,\r\n            warnings,\r\n            imageType: lemGendImage.type,\r\n            dimensions: { width: lemGendImage.width, height: lemGendImage.height }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process an image with resize operation\r\n     * @param {LemGendImage} lemGendImage - Image to process\r\n     * @returns {Promise<Object>} Processing result with new dimensions\r\n     */\r\n    process = async (lemGendImage) => {\r\n        // Validate options\r\n        const optionsValidation = this._validateOptions()\r\n\r\n        // Validate image\r\n        const imageValidation = this._validateImage(lemGendImage)\r\n\r\n        if (!imageValidation.canProcess) {\r\n            throw new Error(`Cannot process image: ${imageValidation.errors.join(', ')}`)\r\n        }\r\n\r\n        const originalWidth = lemGendImage.width\r\n        const originalHeight = lemGendImage.height\r\n        const originalOrientation = lemGendImage.orientation\r\n        const originalAspect = originalWidth / originalHeight\r\n\r\n        // Calculate new dimensions based on image's longest side\r\n        const newDimensions = this._calculateDimensionsForImage(\r\n            originalWidth,\r\n            originalHeight,\r\n            originalOrientation\r\n        )\r\n\r\n        // Validate against upscaling policy\r\n        const upscaleValidation = this._validateUpscaling(originalWidth, originalHeight, newDimensions)\r\n        if (!upscaleValidation.valid) {\r\n            throw new Error(upscaleValidation.message)\r\n        }\r\n\r\n        // Validate output dimensions\r\n        const dimensionValidation = this._validateOutputDimensions(newDimensions)\r\n\r\n        // Create result object\r\n        const result = {\r\n            success: true,\r\n            operation: this.name,\r\n            originalDimensions: {\r\n                width: originalWidth,\r\n                height: originalHeight,\r\n                orientation: originalOrientation,\r\n                aspectRatio: originalAspect\r\n            },\r\n            newDimensions: {\r\n                width: newDimensions.width,\r\n                height: newDimensions.height,\r\n                orientation: newDimensions.width >= newDimensions.height ? 'landscape' : 'portrait',\r\n                aspectRatio: newDimensions.width / newDimensions.height\r\n            },\r\n            settings: {\r\n                targetLongestDimension: this.dimension,\r\n                algorithm: this.algorithm,\r\n                upscale: this.upscale,\r\n                forceSquare: this.forceSquare,\r\n                preserveAspectRatio: this.preserveAspectRatio,\r\n                mode: this.mode,\r\n                skipSvg: this.skipSvg\r\n            },\r\n            warnings: [...optionsValidation.warnings, ...imageValidation.warnings, ...dimensionValidation.warnings],\r\n            recommendations: [],\r\n            metadata: {\r\n                scaleFactor: newDimensions.width / originalWidth,\r\n                aspectRatioPreserved: this.preserveAspectRatio,\r\n                aspectRatioChange: Math.abs((newDimensions.width / newDimensions.height) - originalAspect),\r\n                processedAt: new Date().toISOString(),\r\n                isSquare: newDimensions.width === newDimensions.height,\r\n                longestDimensionApplied: newDimensions.width >= newDimensions.height ? 'width' : 'height',\r\n                appliedTo: this._getAppliedDimension(originalWidth, originalHeight),\r\n                targetValue: this.dimension,\r\n                validation: {\r\n                    optionsValid: optionsValidation.errors.length === 0,\r\n                    imageValid: imageValidation.canProcess,\r\n                    upscaleValid: upscaleValidation.valid,\r\n                    outputDimensionsValid: dimensionValidation.valid\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add warnings and recommendations if needed\r\n        this._addWarningsAndRecommendations(lemGendImage, originalWidth, originalHeight, newDimensions, result)\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Calculate new dimensions for THIS specific image\r\n     * @private\r\n     */\r\n    _calculateDimensionsForImage = (originalWidth, originalHeight, originalOrientation) => {\r\n        let newWidth, newHeight\r\n\r\n        // Handle different resize modes\r\n        switch (this.mode) {\r\n            case 'width':\r\n                newWidth = this.dimension\r\n                newHeight = this.preserveAspectRatio\r\n                    ? Math.round((originalHeight / originalWidth) * this.dimension)\r\n                    : this.dimension\r\n                break\r\n\r\n            case 'height':\r\n                newHeight = this.dimension\r\n                newWidth = this.preserveAspectRatio\r\n                    ? Math.round((originalWidth / originalHeight) * this.dimension)\r\n                    : this.dimension\r\n                break\r\n\r\n            case 'auto':\r\n                // Auto mode: portrait uses height, landscape uses width\r\n                if (originalWidth >= originalHeight) {\r\n                    newWidth = this.dimension\r\n                    newHeight = this.preserveAspectRatio\r\n                        ? Math.round((originalHeight / originalWidth) * this.dimension)\r\n                        : this.dimension\r\n                } else {\r\n                    newHeight = this.dimension\r\n                    newWidth = this.preserveAspectRatio\r\n                        ? Math.round((originalWidth / originalHeight) * this.dimension)\r\n                        : this.dimension\r\n                }\r\n                break\r\n\r\n            case 'longest':\r\n            default:\r\n                // Original logic: longest dimension gets target\r\n                if (this.forceSquare) {\r\n                    // Force square output\r\n                    newWidth = this.dimension\r\n                    newHeight = this.dimension\r\n                } else if (originalWidth >= originalHeight) {\r\n                    // Landscape or square image: width is longer or equal\r\n                    newWidth = this.dimension\r\n                    newHeight = this.preserveAspectRatio\r\n                        ? Math.round((originalHeight / originalWidth) * this.dimension)\r\n                        : this.dimension\r\n                } else {\r\n                    // Portrait image: height is longer\r\n                    newHeight = this.dimension\r\n                    newWidth = this.preserveAspectRatio\r\n                        ? Math.round((originalWidth / originalHeight) * this.dimension)\r\n                        : this.dimension\r\n                }\r\n        }\r\n\r\n        // Ensure minimum dimensions\r\n        newWidth = Math.max(1, newWidth)\r\n        newHeight = Math.max(1, newHeight)\r\n\r\n        // Apply max dimension limit\r\n        if (newWidth > this.maxDimension || newHeight > this.maxDimension) {\r\n            const scale = Math.min(this.maxDimension / newWidth, this.maxDimension / newHeight)\r\n            newWidth = Math.round(newWidth * scale)\r\n            newHeight = Math.round(newHeight * scale)\r\n        }\r\n\r\n        return { width: newWidth, height: newHeight }\r\n    }\r\n\r\n    /**\r\n     * Get which dimension the target was applied to\r\n     * @private\r\n     */\r\n    _getAppliedDimension = (originalWidth, originalHeight) => {\r\n        if (this.forceSquare) {\r\n            return 'both (forced square)'\r\n        }\r\n\r\n        switch (this.mode) {\r\n            case 'width':\r\n                return 'width'\r\n            case 'height':\r\n                return 'height'\r\n            case 'auto':\r\n                return originalWidth >= originalHeight ? 'width (auto)' : 'height (auto)'\r\n            case 'longest':\r\n            default:\r\n                return originalWidth >= originalHeight ? 'width (longest)' : 'height (longest)'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate upscaling policy\r\n     * @private\r\n     */\r\n    _validateUpscaling = (originalWidth, originalHeight, newDimensions) => {\r\n        const scaleUpWidth = newDimensions.width > originalWidth\r\n        const scaleUpHeight = newDimensions.height > originalHeight\r\n\r\n        if ((scaleUpWidth || scaleUpHeight) && !this.upscale) {\r\n            return {\r\n                valid: false,\r\n                message: `Upscaling detected (${originalWidth}x${originalHeight} → ${newDimensions.width}x${newDimensions.height}). Set upscale: true to allow upscaling.`\r\n            }\r\n        }\r\n\r\n        return { valid: true }\r\n    }\r\n\r\n    /**\r\n     * Validate output dimensions\r\n     * @private\r\n     */\r\n    _validateOutputDimensions = (dimensions) => {\r\n        const warnings = []\r\n        let valid = true\r\n\r\n        const { width, height } = dimensions\r\n\r\n        // Check minimum dimensions\r\n        if (width < 10 || height < 10) {\r\n            warnings.push({\r\n                code: 'OUTPUT_TOO_SMALL',\r\n                message: `Output dimensions very small: ${width}x${height}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider larger target dimension'\r\n            })\r\n        }\r\n\r\n        // Check for extreme aspect ratios in output\r\n        const aspectRatio = width / height\r\n        if (aspectRatio > 10 || aspectRatio < 0.1) {\r\n            warnings.push({\r\n                code: 'EXTREME_OUTPUT_ASPECT',\r\n                message: `Extreme output aspect ratio: ${aspectRatio.toFixed(2)}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider cropping or different resize mode'\r\n            })\r\n        }\r\n\r\n        // Check if dimensions are too large\r\n        if (width * height > 100000000) { // > 100 megapixels\r\n            warnings.push({\r\n                code: 'OUTPUT_TOO_LARGE',\r\n                message: `Output image very large: ${Math.round(width * height / 1000000)}MP`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider smaller target dimension'\r\n            })\r\n        }\r\n\r\n        return { valid, warnings }\r\n    }\r\n\r\n    /**\r\n     * Add warnings and recommendations to result\r\n     * @private\r\n     */\r\n    _addWarningsAndRecommendations = (lemGendImage, originalWidth, originalHeight, newDimensions, result) => {\r\n        const scaleFactor = newDimensions.width / originalWidth\r\n        const newAspect = newDimensions.width / newDimensions.height\r\n        const originalAspect = originalWidth / originalHeight\r\n        const aspectDiff = Math.abs(originalAspect - newAspect) / originalAspect\r\n\r\n        // Extreme scaling warnings\r\n        if (scaleFactor < 0.1) {\r\n            result.warnings.push({\r\n                type: 'EXTREME_DOWNSCALE',\r\n                message: `Downscaling by ${((1 - scaleFactor) * 100).toFixed(1)}% may cause severe pixelation`,\r\n                severity: 'warning',\r\n                suggestion: this.algorithm === 'nearest'\r\n                    ? 'Nearest-neighbor algorithm selected for pixel art'\r\n                    : 'Consider using nearest-neighbor algorithm for pixel art'\r\n            })\r\n        }\r\n\r\n        if (scaleFactor > 4) {\r\n            result.warnings.push({\r\n                type: 'EXTREME_UPSCALE',\r\n                message: `Upscaling by ${((scaleFactor - 1) * 100).toFixed(1)}% may reduce quality`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider using AI upscaling tools for better results'\r\n            })\r\n        }\r\n\r\n        // Aspect ratio warnings\r\n        if (aspectDiff > 0.01 && this.preserveAspectRatio) {\r\n            result.warnings.push({\r\n                type: 'ASPECT_DEVIATION',\r\n                message: `Aspect ratio changed from ${originalAspect.toFixed(3)} to ${newAspect.toFixed(3)}`,\r\n                severity: 'info',\r\n                suggestion: 'Check if this deviation is acceptable for your use case'\r\n            })\r\n        }\r\n\r\n        if (!this.preserveAspectRatio && !this.forceSquare) {\r\n            result.warnings.push({\r\n                type: 'ASPECT_RATIO_NOT_PRESERVED',\r\n                message: 'Aspect ratio is not being preserved',\r\n                severity: 'info',\r\n                suggestion: 'Content may appear stretched or compressed'\r\n            })\r\n        }\r\n\r\n        if (this.forceSquare && originalAspect !== 1) {\r\n            result.warnings.push({\r\n                type: 'FORCED_SQUARE',\r\n                message: 'Image will be forced to square, cropping may occur',\r\n                severity: 'warning',\r\n                suggestion: originalAspect > 1\r\n                    ? 'Consider cropping horizontally before resizing'\r\n                    : 'Consider cropping vertically before resizing'\r\n            })\r\n        }\r\n\r\n        // Format-specific recommendations\r\n        if (lemGendImage.type === 'image/jpeg' || lemGendImage.type === 'image/jpg') {\r\n            result.recommendations.push({\r\n                type: 'FORMAT_SUGGESTION',\r\n                message: 'JPEG format selected',\r\n                suggestion: 'Consider WebP for better compression after resizing'\r\n            })\r\n        }\r\n\r\n        if (lemGendImage.transparency && (lemGendImage.type === 'image/png' || lemGendImage.type === 'image/webp')) {\r\n            result.warnings.push({\r\n                type: 'TRANSPARENCY_WARNING',\r\n                message: 'Image has transparency',\r\n                severity: 'info',\r\n                suggestion: 'Transparency will be preserved during resize'\r\n            })\r\n        }\r\n\r\n        // Add info about what was resized\r\n        result.metadata.resizeInfo = `Target dimension ${this.dimension}px applied using ${this.mode} mode`\r\n        result.metadata.scaleDirection = scaleFactor > 1 ? 'upscale' : 'downscale'\r\n        result.metadata.scalePercentage = `${(Math.abs(scaleFactor - 1) * 100).toFixed(1)}%`\r\n    }\r\n\r\n    /**\r\n     * Process multiple images in batch\r\n     * @param {Array<LemGendImage>} images - Images to process\r\n     * @returns {Promise<Array<Object>>} Array of processing results\r\n     */\r\n    processBatch = async (images) => {\r\n        this._validateOptions()\r\n\r\n        if (!Array.isArray(images)) {\r\n            throw new Error('Images must be provided as an array')\r\n        }\r\n\r\n        const results = []\r\n        const batchWarnings = []\r\n\r\n        // Check batch size\r\n        if (images.length > 50) {\r\n            batchWarnings.push({\r\n                code: 'LARGE_BATCH',\r\n                message: `Large batch size: ${images.length} images`,\r\n                severity: 'info',\r\n                suggestion: 'Consider processing in smaller batches for better performance'\r\n            })\r\n        }\r\n\r\n        for (const image of images) {\r\n            try {\r\n                const result = await this.process(image)\r\n                results.push(result)\r\n            } catch (error) {\r\n                results.push({\r\n                    success: false,\r\n                    error: error.message,\r\n                    imageName: image?.originalName || 'Unknown',\r\n                    imageType: image?.type || 'Unknown',\r\n                    operation: this.name,\r\n                    warnings: batchWarnings\r\n                })\r\n            }\r\n        }\r\n\r\n        // Add batch summary\r\n        if (results.length > 0) {\r\n            const successful = results.filter(r => r.success).length\r\n            const failed = results.filter(r => !r.success).length\r\n\r\n            results.batchSummary = {\r\n                total: results.length,\r\n                successful,\r\n                failed,\r\n                successRate: ((successful / results.length) * 100).toFixed(1) + '%',\r\n                warnings: batchWarnings\r\n            }\r\n        }\r\n\r\n        return results\r\n    }\r\n\r\n    /**\r\n     * Get processor description\r\n     * @returns {string} Description\r\n     */\r\n    static getDescription() {\r\n        return 'LemGendaryResize™: Intelligent image resizing with enhanced validation and multiple resize modes.'\r\n    }\r\n\r\n    /**\r\n     * Get processor information\r\n     * @returns {Object} Processor info\r\n     */\r\n    static getInfo() {\r\n        return {\r\n            name: 'LemGendaryResize',\r\n            version: '2.0.0',\r\n            description: this.getDescription(),\r\n            operation: 'Resizes images with multiple mode options and enhanced validation',\r\n            algorithms: ['lanczos3', 'bilinear', 'nearest', 'cubic', 'mitchell'],\r\n            modes: ['longest', 'width', 'height', 'auto'],\r\n            defaultDimension: 1080,\r\n            minDimension: 1,\r\n            maxDimension: 10000,\r\n            supportsSvg: true,\r\n            supportsFavicon: true,\r\n            features: [\r\n                'Enhanced validation',\r\n                'Multiple resize modes',\r\n                'Batch processing',\r\n                'Upscale control',\r\n                'Aspect ratio preservation',\r\n                'Square output option'\r\n            ]\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create processor from configuration object\r\n     * @param {Object} config - Processor configuration\r\n     * @returns {LemGendaryResize} New processor instance\r\n     */\r\n    static fromConfig(config) {\r\n        return new LemGendaryResize(config)\r\n    }\r\n\r\n    /**\r\n     * Preview resize for an image without processing\r\n     * @param {number} originalWidth - Original width\r\n     * @param {number} originalHeight - Original height\r\n     * @param {number} targetDimension - Target dimension for longest side\r\n     * @param {boolean} forceSquare - Force square output\r\n     * @param {string} mode - Resize mode\r\n     * @returns {Object} Preview dimensions with validation\r\n     */\r\n    static previewResize(originalWidth, originalHeight, targetDimension = 1080, forceSquare = false, mode = 'longest') {\r\n        const processor = new LemGendaryResize({\r\n            dimension: targetDimension,\r\n            forceSquare,\r\n            mode\r\n        })\r\n\r\n        const newDimensions = processor._calculateDimensionsForImage(\r\n            originalWidth,\r\n            originalHeight,\r\n            originalWidth >= originalHeight ? 'landscape' : 'portrait'\r\n        )\r\n\r\n        const warnings = []\r\n        const recommendations = []\r\n\r\n        // Add preview warnings\r\n        const scaleFactor = newDimensions.width / originalWidth\r\n        if (scaleFactor < 0.1) {\r\n            warnings.push('Extreme downscaling may cause pixelation')\r\n        }\r\n        if (scaleFactor > 4) {\r\n            warnings.push('Extreme upscaling may reduce quality')\r\n        }\r\n\r\n        // Add format recommendations\r\n        if (forceSquare && (originalWidth / originalHeight) !== 1) {\r\n            recommendations.push('Consider cropping before forcing square')\r\n        }\r\n\r\n        return {\r\n            original: `${originalWidth}x${originalHeight}`,\r\n            new: `${newDimensions.width}x${newDimensions.height}`,\r\n            appliedTo: processor._getAppliedDimension(originalWidth, originalHeight),\r\n            aspectRatio: {\r\n                original: (originalWidth / originalHeight).toFixed(2),\r\n                new: (newDimensions.width / newDimensions.height).toFixed(2)\r\n            },\r\n            scaleFactor: scaleFactor.toFixed(2),\r\n            warnings,\r\n            recommendations\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate if processor can handle given image\r\n     * @param {LemGendImage} image - Image to check\r\n     * @returns {Object} Validation result\r\n     */\r\n    static canProcess(image) {\r\n        const validTypes = [\r\n            'image/jpeg',\r\n            'image/jpg',\r\n            'image/png',\r\n            'image/webp',\r\n            'image/gif',\r\n            'image/bmp',\r\n            'image/svg+xml',\r\n            'image/x-icon',\r\n            'image/vnd.microsoft.icon',\r\n            'image/avif'\r\n        ]\r\n\r\n        const canProcess = validTypes.includes(image.type)\r\n        const reason = canProcess\r\n            ? 'Image type supported'\r\n            : `Unsupported image type: ${image.type}`\r\n\r\n        const warnings = []\r\n        if (image.type === 'image/svg+xml') {\r\n            warnings.push('SVG files are vector-based and may be rasterized')\r\n        }\r\n        if (image.type.includes('icon')) {\r\n            warnings.push('ICO files contain multiple images')\r\n        }\r\n\r\n        return {\r\n            canProcess,\r\n            reason,\r\n            warnings,\r\n            supportedTypes: validTypes,\r\n            enhancedValidation: true\r\n        }\r\n    }\r\n}","/**\r\n * LemGendaryCrop™ - Intelligent smart crop processor with enhanced validation\r\n * @class\r\n * @description Smart cropping with AI detection, resizing, and content-aware cropping\r\n */\r\nexport class LemGendaryCrop {\r\n    /**\r\n     * Create a LemGendaryCrop processor\r\n     * @param {Object} options - Crop options\r\n     * @param {number} options.width - Target width in pixels\r\n     * @param {number} options.height - Target height in pixels\r\n     * @param {string} options.mode - 'smart', 'face', 'object', 'saliency', 'entropy', 'center', 'top', 'bottom', 'left', 'right'\r\n     * @param {boolean} options.upscale - Allow upscaling (default: false)\r\n     * @param {string} options.algorithm - Resize algorithm for pre-scaling\r\n     * @param {boolean} options.preserveAspectRatio - Maintain aspect ratio during resize (default: true)\r\n     * @param {number} options.confidenceThreshold - Confidence threshold for AI detection (0-100)\r\n     * @param {boolean} options.multipleFaces - Handle multiple faces (for face mode)\r\n     * @param {Array<string>} options.objectsToDetect - Specific objects to look for ['person', 'car', 'dog', etc.]\r\n     * @param {boolean} options.cropToFit - Crop to fit exact dimensions after resize (default: true)\r\n     * @param {boolean} options.skipSvg - Skip SVG files (default: true)\r\n     * @param {number} options.minSourceDimension - Minimum source dimension for AI to work\r\n     * @param {boolean} options.fallbackToSimple - Fallback to simple crop if AI fails\r\n     */\r\n    constructor(options = {}) {\r\n        this.width = options.width || 1080\r\n        this.height = options.height || 1080\r\n        this.mode = options.mode || 'smart'\r\n        this.upscale = options.upscale || false\r\n        this.algorithm = options.algorithm || 'lanczos3'\r\n        this.preserveAspectRatio = options.preserveAspectRatio !== false\r\n        this.confidenceThreshold = Math.max(0, Math.min(100, options.confidenceThreshold || 70))\r\n        this.multipleFaces = options.multipleFaces || false\r\n        this.objectsToDetect = options.objectsToDetect || ['person', 'face', 'car', 'dog', 'cat']\r\n        this.cropToFit = options.cropToFit !== false\r\n        this.skipSvg = options.skipSvg !== false\r\n        this.minSourceDimension = options.minSourceDimension || 200\r\n        this.fallbackToSimple = options.fallbackToSimple !== false\r\n\r\n        this.name = 'LemGendaryCrop'\r\n        this.version = '3.0.0' // Major update for enhanced validation\r\n        this.aiCapabilities = null // Will be populated\r\n    }\r\n\r\n    /**\r\n     * Validate processor options with enhanced validation\r\n     * @private\r\n     */\r\n    _validateOptions = async () => {\r\n        const errors = []\r\n        const warnings = []\r\n\r\n        // Validate dimensions\r\n        if (typeof this.width !== 'number' || this.width <= 0) {\r\n            errors.push({\r\n                code: 'INVALID_WIDTH',\r\n                message: 'Width must be a positive number',\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        if (typeof this.height !== 'number' || this.height <= 0) {\r\n            errors.push({\r\n                code: 'INVALID_HEIGHT',\r\n                message: 'Height must be a positive number',\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Check for extreme dimensions\r\n        if (this.width < 10 || this.height < 10) {\r\n            errors.push({\r\n                code: 'EXTREME_SMALL_DIMENSIONS',\r\n                message: `Target dimensions too small: ${this.width}x${this.height}`,\r\n                severity: 'error',\r\n                suggestion: 'Use dimensions of at least 100x100 pixels'\r\n            })\r\n        }\r\n\r\n        if (this.width > 10000 || this.height > 10000) {\r\n            warnings.push({\r\n                code: 'EXTREME_LARGE_DIMENSIONS',\r\n                message: `Target dimensions very large: ${this.width}x${this.height}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider smaller dimensions for better performance'\r\n            })\r\n        }\r\n\r\n        // Validate aspect ratio\r\n        const aspectRatio = this.width / this.height\r\n        if (aspectRatio > 10 || aspectRatio < 0.1) {\r\n            warnings.push({\r\n                code: 'EXTREME_ASPECT_RATIO',\r\n                message: `Extreme aspect ratio: ${aspectRatio.toFixed(2)}`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider more balanced dimensions'\r\n            })\r\n        }\r\n\r\n        // Validate mode\r\n        const validModes = [\r\n            'smart', 'face', 'object', 'saliency', 'entropy',\r\n            'center', 'top', 'bottom', 'left', 'right',\r\n            'top-left', 'top-right', 'bottom-left', 'bottom-right'\r\n        ]\r\n\r\n        if (!validModes.includes(this.mode)) {\r\n            errors.push({\r\n                code: 'INVALID_MODE',\r\n                message: `Mode must be one of: ${validModes.join(', ')}`,\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Validate algorithm\r\n        if (!['lanczos3', 'bilinear', 'nearest'].includes(this.algorithm)) {\r\n            errors.push({\r\n                code: 'INVALID_ALGORITHM',\r\n                message: 'Algorithm must be \"lanczos3\", \"bilinear\", or \"nearest\"',\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Validate confidence threshold\r\n        if (this.confidenceThreshold < 30) {\r\n            warnings.push({\r\n                code: 'LOW_CONFIDENCE_THRESHOLD',\r\n                message: `Low confidence threshold: ${this.confidenceThreshold}%`,\r\n                severity: 'warning',\r\n                suggestion: 'Use at least 50% for reliable detection'\r\n            })\r\n        }\r\n\r\n        // Check AI capabilities for smart modes\r\n        if (['smart', 'face', 'object', 'saliency', 'entropy'].includes(this.mode)) {\r\n            this.aiCapabilities = await this._checkAICapabilities()\r\n\r\n            if (this.mode === 'face' && !this.aiCapabilities.faceDetection) {\r\n                warnings.push({\r\n                    code: 'FACE_DETECTION_UNAVAILABLE',\r\n                    message: 'Face detection API not available',\r\n                    severity: 'warning',\r\n                    suggestion: 'Browser may not support FaceDetector API, will use fallback'\r\n                })\r\n            }\r\n\r\n            if (this.mode === 'object' && !this.aiCapabilities.objectDetection) {\r\n                warnings.push({\r\n                    code: 'OBJECT_DETECTION_UNAVAILABLE',\r\n                    message: 'Object detection not available',\r\n                    severity: 'warning',\r\n                    suggestion: 'TensorFlow.js not loaded, will use saliency detection'\r\n                })\r\n            }\r\n\r\n            if (this.mode === 'saliency' && !this.aiCapabilities.canvasAvailable) {\r\n                errors.push({\r\n                    code: 'SALIENCY_DETECTION_UNAVAILABLE',\r\n                    message: 'Canvas API not available for saliency detection',\r\n                    severity: 'error'\r\n                })\r\n            }\r\n        }\r\n\r\n        // Check for integer dimensions\r\n        if (!Number.isInteger(this.width) || !Number.isInteger(this.height)) {\r\n            warnings.push({\r\n                code: 'NON_INTEGER_DIMENSIONS',\r\n                message: 'Crop dimensions should be integers for best results',\r\n                severity: 'info'\r\n            })\r\n            this.width = Math.round(this.width)\r\n            this.height = Math.round(this.height)\r\n        }\r\n\r\n        // Validate objectsToDetect array\r\n        if (!Array.isArray(this.objectsToDetect)) {\r\n            errors.push({\r\n                code: 'INVALID_OBJECTS_ARRAY',\r\n                message: 'objectsToDetect must be an array',\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        // Check if objectsToDetect is empty when mode is 'object'\r\n        if (this.mode === 'object' && (!this.objectsToDetect || this.objectsToDetect.length === 0)) {\r\n            warnings.push({\r\n                code: 'NO_OBJECTS_SPECIFIED',\r\n                message: 'No objects specified for object detection',\r\n                severity: 'warning',\r\n                suggestion: 'Add objects to detect like [\"person\", \"car\", \"dog\"]'\r\n            })\r\n        }\r\n\r\n        // Throw errors if any\r\n        if (errors.length > 0) {\r\n            const errorMessages = errors.map(e => e.message).join(', ')\r\n            throw new Error(`Invalid crop options: ${errorMessages}`)\r\n        }\r\n\r\n        // Return warnings for processing\r\n        return { errors, warnings }\r\n    }\r\n\r\n    /**\r\n     * Validate if image can be processed with smart crop\r\n     * @private\r\n     */\r\n    _validateImage = (lemGendImage) => {\r\n        const errors = []\r\n        const warnings = []\r\n\r\n        if (!lemGendImage) {\r\n            errors.push('No image provided')\r\n            return { canProcess: false, errors, warnings }\r\n        }\r\n\r\n        if (!lemGendImage.width || !lemGendImage.height) {\r\n            errors.push('Image missing dimensions')\r\n            return { canProcess: false, errors, warnings }\r\n        }\r\n\r\n        // Check for SVG\r\n        if (lemGendImage.type === 'image/svg+xml') {\r\n            if (this.skipSvg) {\r\n                warnings.push({\r\n                    code: 'SVG_SKIPPED',\r\n                    message: 'SVG files are vector-based and smart cropping may not work well',\r\n                    severity: 'info',\r\n                    suggestion: 'Consider converting to raster format first'\r\n                })\r\n                return { canProcess: false, errors, warnings }\r\n            } else {\r\n                warnings.push({\r\n                    code: 'SVG_RASTERIZED',\r\n                    message: 'SVG will be rasterized before smart cropping',\r\n                    severity: 'warning'\r\n                })\r\n            }\r\n        }\r\n\r\n        // Check for ICO/favicon\r\n        if (lemGendImage.type.includes('icon')) {\r\n            warnings.push({\r\n                code: 'FAVICON_SMART_CROP',\r\n                message: 'ICO files contain multiple images; smart cropping may affect all frames',\r\n                severity: 'info'\r\n            })\r\n        }\r\n\r\n        // Check minimum source dimensions for AI\r\n        if (['smart', 'face', 'object', 'saliency', 'entropy'].includes(this.mode)) {\r\n            const minDimension = Math.min(lemGendImage.width, lemGendImage.height)\r\n            if (minDimension < this.minSourceDimension) {\r\n                warnings.push({\r\n                    code: 'SMALL_SOURCE_FOR_AI',\r\n                    message: `Source image small (${lemGendImage.width}x${lemGendImage.height}), AI may not work well`,\r\n                    severity: 'warning',\r\n                    suggestion: 'Use larger source image or simple crop mode'\r\n                })\r\n            }\r\n        }\r\n\r\n        // Check for extreme source aspect ratios\r\n        const sourceAspect = lemGendImage.width / lemGendImage.height\r\n        const targetAspect = this.width / this.height\r\n        const aspectDiff = Math.abs(sourceAspect - targetAspect) / sourceAspect\r\n\r\n        if (aspectDiff > 2) { // More than 200% difference\r\n            warnings.push({\r\n                code: 'EXTREME_ASPECT_MISMATCH',\r\n                message: `Source aspect ratio (${sourceAspect.toFixed(2)}) very different from target (${targetAspect.toFixed(2)})`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider cropping before smart crop or adjust target dimensions'\r\n            })\r\n        }\r\n\r\n        // Check if image is too small for target\r\n        if (!this.upscale && (lemGendImage.width < this.width || lemGendImage.height < this.height)) {\r\n            warnings.push({\r\n                code: 'UPSCALING_REQUIRED',\r\n                message: 'Target dimensions larger than source, upscaling disabled',\r\n                severity: 'warning',\r\n                suggestion: 'Enable upscaling or use smaller target dimensions'\r\n            })\r\n        }\r\n\r\n        return {\r\n            canProcess: true,\r\n            errors,\r\n            warnings,\r\n            imageType: lemGendImage.type,\r\n            dimensions: { width: lemGendImage.width, height: lemGendImage.height }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check available AI capabilities with detailed reporting\r\n     * @private\r\n     */\r\n    _checkAICapabilities = async () => {\r\n        const capabilities = {\r\n            faceDetection: false,\r\n            objectDetection: false,\r\n            saliencyDetection: false,\r\n            entropyDetection: false,\r\n            canvasAvailable: false,\r\n            workerAvailable: typeof Worker !== 'undefined',\r\n            tensorFlowAvailable: typeof tf !== 'undefined',\r\n            faceDetectorAvailable: typeof FaceDetector !== 'undefined'\r\n        }\r\n\r\n        try {\r\n            // Check canvas API\r\n            const canvas = document.createElement('canvas')\r\n            capabilities.canvasAvailable = !!(canvas.getContext && canvas.getContext('2d'))\r\n\r\n            // Check Face Detection API\r\n            if (typeof FaceDetector === 'function') {\r\n                try {\r\n                    const faceDetector = new FaceDetector()\r\n                    capabilities.faceDetection = true\r\n                } catch (e) {\r\n                    console.warn('FaceDetector API available but failed to initialize:', e.message)\r\n                }\r\n            }\r\n\r\n            // Check TensorFlow.js\r\n            if (typeof tf !== 'undefined') {\r\n                capabilities.tensorFlowAvailable = true\r\n                capabilities.objectDetection = true\r\n                capabilities.saliencyDetection = true\r\n                capabilities.entropyDetection = true\r\n            }\r\n\r\n            // Check for offscreen canvas for workers\r\n            if (typeof OffscreenCanvas !== 'undefined') {\r\n                capabilities.offscreenCanvas = true\r\n            }\r\n\r\n        } catch (error) {\r\n            console.warn('Error checking AI capabilities:', error.message)\r\n        }\r\n\r\n        // Generate capability summary\r\n        capabilities.summary = this._generateAISummary(capabilities)\r\n        capabilities.hasAnyAI = capabilities.faceDetection || capabilities.objectDetection ||\r\n            capabilities.saliencyDetection || capabilities.entropyDetection\r\n\r\n        return capabilities\r\n    }\r\n\r\n    /**\r\n     * Generate AI capability summary\r\n     * @private\r\n     */\r\n    _generateAISummary = (capabilities) => {\r\n        const availableFeatures = []\r\n        const unavailableFeatures = []\r\n\r\n        if (capabilities.faceDetection) availableFeatures.push('Face Detection')\r\n        else unavailableFeatures.push('Face Detection (requires FaceDetector API)')\r\n\r\n        if (capabilities.objectDetection) availableFeatures.push('Object Detection')\r\n        else unavailableFeatures.push('Object Detection (requires TensorFlow.js)')\r\n\r\n        if (capabilities.saliencyDetection) availableFeatures.push('Saliency Detection')\r\n        else unavailableFeatures.push('Saliency Detection (requires TensorFlow.js)')\r\n\r\n        if (capabilities.entropyDetection) availableFeatures.push('Entropy Analysis')\r\n        else unavailableFeatures.push('Entropy Analysis (requires TensorFlow.js)')\r\n\r\n        return {\r\n            available: availableFeatures,\r\n            unavailable: unavailableFeatures,\r\n            hasAdvancedAI: capabilities.tensorFlowAvailable,\r\n            canUseWorkers: capabilities.workerAvailable && capabilities.offscreenCanvas,\r\n            recommendedMode: capabilities.faceDetection ? 'face' :\r\n                capabilities.objectDetection ? 'object' :\r\n                    capabilities.saliencyDetection ? 'saliency' : 'center'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process an image with smart crop operation\r\n     * @param {LemGendImage} lemGendImage - Image to process\r\n     * @param {Object} previousDimensions - Optional dimensions from previous step\r\n     * @returns {Promise<Object>} Processing result with smart crop details\r\n     */\r\n    process = async (lemGendImage, previousDimensions = null) => {\r\n        // Validate options\r\n        const optionsValidation = await this._validateOptions()\r\n\r\n        // Validate image\r\n        const imageValidation = this._validateImage(lemGendImage)\r\n\r\n        if (!imageValidation.canProcess) {\r\n            if (this.fallbackToSimple && ['center', 'top', 'bottom', 'left', 'right'].includes(this.mode)) {\r\n                console.warn('Smart crop not possible, falling back to simple crop')\r\n                return this._fallbackToSimpleCrop(lemGendImage, previousDimensions)\r\n            }\r\n            throw new Error(`Cannot process image: ${imageValidation.errors.join(', ')}`)\r\n        }\r\n\r\n        const sourceWidth = previousDimensions?.width || lemGendImage.width\r\n        const sourceHeight = previousDimensions?.height || lemGendImage.height\r\n\r\n        console.log(`Smart crop starting: ${sourceWidth}x${sourceHeight} -> ${this.width}x${this.height}`)\r\n\r\n        // STEP 1: Detect region of interest with fallback handling\r\n        let detectionResult\r\n        try {\r\n            detectionResult = await this._detectRegionOfInterest(lemGendImage)\r\n\r\n            // Check if detection was successful\r\n            if (detectionResult.confidence < this.confidenceThreshold / 100 && this.fallbackToSimple) {\r\n                console.warn(`Low confidence (${detectionResult.confidence}), falling back to ${this.mode} mode`)\r\n                detectionResult.focusPoint = this._getFocusPointForMode(this.mode, sourceWidth, sourceHeight)\r\n            }\r\n        } catch (error) {\r\n            console.warn('Detection failed, using fallback:', error.message)\r\n            if (this.fallbackToSimple) {\r\n                detectionResult = {\r\n                    focusPoint: this._getFocusPointForMode(this.mode, sourceWidth, sourceHeight),\r\n                    confidence: 0.5,\r\n                    usingFallback: true\r\n                }\r\n            } else {\r\n                throw new Error(`Detection failed: ${error.message}`)\r\n            }\r\n        }\r\n\r\n        // STEP 2: Calculate resize dimensions with validation\r\n        const resizeResult = this._calculateResizeDimensions(\r\n            sourceWidth,\r\n            sourceHeight,\r\n            detectionResult\r\n        )\r\n\r\n        // Validate resize result\r\n        const resizeValidation = this._validateResizeDimensions(resizeResult, sourceWidth, sourceHeight)\r\n        if (!resizeValidation.valid) {\r\n            if (this.fallbackToSimple) {\r\n                console.warn('Resize validation failed, using simple crop')\r\n                return this._fallbackToSimpleCrop(lemGendImage, previousDimensions)\r\n            }\r\n            throw new Error(`Resize calculation failed: ${resizeValidation.errors.join(', ')}`)\r\n        }\r\n\r\n        // STEP 3: Calculate crop area based on ROI and target dimensions\r\n        let cropResult\r\n        try {\r\n            cropResult = await this._calculateSmartCropArea(\r\n                detectionResult,\r\n                resizeResult,\r\n                sourceWidth,\r\n                sourceHeight\r\n            )\r\n        } catch (error) {\r\n            console.warn('Smart crop calculation failed:', error.message)\r\n            if (this.fallbackToSimple) {\r\n                return this._fallbackToSimpleCrop(lemGendImage, previousDimensions)\r\n            }\r\n            throw error\r\n        }\r\n\r\n        // Create comprehensive result object with validation metadata\r\n        const result = {\r\n            success: true,\r\n            operation: this.name,\r\n            smartCrop: true,\r\n            steps: {\r\n                detection: detectionResult,\r\n                resize: resizeResult,\r\n                crop: cropResult\r\n            },\r\n            sourceDimensions: {\r\n                width: sourceWidth,\r\n                height: sourceHeight,\r\n                aspectRatio: sourceWidth / sourceHeight\r\n            },\r\n            targetDimensions: {\r\n                width: this.width,\r\n                height: this.height,\r\n                aspectRatio: this.width / this.height\r\n            },\r\n            finalDimensions: {\r\n                width: cropResult.finalWidth || this.width,\r\n                height: cropResult.finalHeight || this.height\r\n            },\r\n            cropOffsets: {\r\n                x: cropResult.cropX,\r\n                y: cropResult.cropY,\r\n                width: cropResult.cropWidth || this.width,\r\n                height: cropResult.cropHeight || this.height\r\n            },\r\n            settings: {\r\n                mode: this.mode,\r\n                width: this.width,\r\n                height: this.height,\r\n                algorithm: this.algorithm,\r\n                upscale: this.upscale,\r\n                preserveAspectRatio: this.preserveAspectRatio,\r\n                confidenceThreshold: this.confidenceThreshold,\r\n                cropToFit: this.cropToFit,\r\n                fallbackToSimple: this.fallbackToSimple\r\n            },\r\n            warnings: [...optionsValidation.warnings, ...imageValidation.warnings, ...resizeValidation.warnings],\r\n            recommendations: [],\r\n            metadata: {\r\n                detectedObjects: detectionResult.objects?.length || 0,\r\n                hasFaces: detectionResult.faces?.length > 0,\r\n                hasSaliency: detectionResult.saliencyArea !== null,\r\n                contentPreserved: this._calculateContentPreservation(detectionResult, cropResult),\r\n                aiCapabilities: this.aiCapabilities?.summary,\r\n                usingFallback: detectionResult.usingFallback || false,\r\n                validation: {\r\n                    optionsValid: optionsValidation.errors.length === 0,\r\n                    imageValid: imageValidation.canProcess,\r\n                    resizeValid: resizeValidation.valid,\r\n                    aiAvailable: this.aiCapabilities?.hasAnyAI || false\r\n                },\r\n                processingTime: Date.now(),\r\n                processedAt: new Date().toISOString()\r\n            }\r\n        }\r\n\r\n        // Add warnings and recommendations\r\n        this._addSmartCropWarnings(detectionResult, resizeResult, cropResult, result)\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Fallback to simple crop when AI/smart crop fails\r\n     * @private\r\n     */\r\n    _fallbackToSimpleCrop = (lemGendImage, previousDimensions) => {\r\n        const sourceWidth = previousDimensions?.width || lemGendImage.width\r\n        const sourceHeight = previousDimensions?.height || lemGendImage.height\r\n\r\n        const cropResult = LemGendaryCrop.simpleCrop(\r\n            sourceWidth,\r\n            sourceHeight,\r\n            this.width,\r\n            this.height,\r\n            this.mode\r\n        )\r\n\r\n        const result = {\r\n            success: true,\r\n            operation: this.name,\r\n            smartCrop: false,\r\n            fallbackUsed: true,\r\n            sourceDimensions: {\r\n                width: sourceWidth,\r\n                height: sourceHeight,\r\n                aspectRatio: sourceWidth / sourceHeight\r\n            },\r\n            targetDimensions: {\r\n                width: this.width,\r\n                height: this.height,\r\n                aspectRatio: this.width / this.height\r\n            },\r\n            finalDimensions: {\r\n                width: this.width,\r\n                height: this.height\r\n            },\r\n            cropOffsets: {\r\n                x: cropResult.cropX,\r\n                y: cropResult.cropY,\r\n                width: cropResult.cropWidth,\r\n                height: cropResult.cropHeight\r\n            },\r\n            settings: {\r\n                mode: this.mode,\r\n                width: this.width,\r\n                height: this.height,\r\n                usingSimpleCrop: true\r\n            },\r\n            warnings: [{\r\n                type: 'AI_UNAVAILABLE',\r\n                message: 'AI features not available, using simple crop',\r\n                severity: 'warning',\r\n                suggestion: 'Check browser compatibility or use simple crop modes'\r\n            }],\r\n            metadata: {\r\n                usingFallback: true,\r\n                fallbackReason: 'AI not available or failed',\r\n                scale: cropResult.scale,\r\n                processingTime: Date.now(),\r\n                processedAt: new Date().toISOString()\r\n            }\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Get focus point for simple crop modes\r\n     * @private\r\n     */\r\n    _getFocusPointForMode = (mode, width, height) => {\r\n        switch (mode) {\r\n            case 'center':\r\n                return { x: width / 2, y: height / 2 }\r\n            case 'top':\r\n                return { x: width / 2, y: height * 0.25 }\r\n            case 'bottom':\r\n                return { x: width / 2, y: height * 0.75 }\r\n            case 'left':\r\n                return { x: width * 0.25, y: height / 2 }\r\n            case 'right':\r\n                return { x: width * 0.75, y: height / 2 }\r\n            case 'top-left':\r\n                return { x: width * 0.25, y: height * 0.25 }\r\n            case 'top-right':\r\n                return { x: width * 0.75, y: height * 0.25 }\r\n            case 'bottom-left':\r\n                return { x: width * 0.25, y: height * 0.75 }\r\n            case 'bottom-right':\r\n                return { x: width * 0.75, y: height * 0.75 }\r\n            default:\r\n                return { x: width / 2, y: height / 2 }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate resize dimensions\r\n     * @private\r\n     */\r\n    _validateResizeDimensions = (resizeResult, sourceWidth, sourceHeight) => {\r\n        const warnings = []\r\n        let valid = true\r\n\r\n        const { width: resizeWidth, height: resizeHeight, requiresUpscaling } = resizeResult\r\n\r\n        // Check for extreme scaling\r\n        const scaleX = resizeWidth / sourceWidth\r\n        const scaleY = resizeHeight / sourceHeight\r\n\r\n        if (scaleX < 0.1 || scaleY < 0.1) {\r\n            warnings.push({\r\n                code: 'EXTREME_DOWNSCALING',\r\n                message: `Extreme downscaling detected (scale: ${Math.min(scaleX, scaleY).toFixed(2)})`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider larger target dimensions or source image'\r\n            })\r\n        }\r\n\r\n        if ((scaleX > 4 || scaleY > 4) && !this.upscale) {\r\n            warnings.push({\r\n                code: 'EXTREME_UPSCALING_NEEDED',\r\n                message: 'Extreme upscaling needed but upscale disabled',\r\n                severity: 'warning',\r\n                suggestion: 'Enable upscaling or use smaller target dimensions'\r\n            })\r\n            valid = false\r\n        }\r\n\r\n        // Check output dimensions\r\n        if (resizeWidth < 10 || resizeHeight < 10) {\r\n            warnings.push({\r\n                code: 'RESIZE_TOO_SMALL',\r\n                message: `Resized dimensions very small: ${resizeWidth}x${resizeHeight}`,\r\n                severity: 'warning'\r\n            })\r\n        }\r\n\r\n        if (resizeWidth * resizeHeight > 100000000) { // > 100MP\r\n            warnings.push({\r\n                code: 'RESIZE_TOO_LARGE',\r\n                message: `Resized image very large: ${Math.round(resizeWidth * resizeHeight / 1000000)}MP`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider smaller target dimensions'\r\n            })\r\n        }\r\n\r\n        return { valid, warnings }\r\n    }\r\n\r\n    /**\r\n     * Calculate resize dimensions\r\n     * @private\r\n     */\r\n    _calculateResizeDimensions = (sourceWidth, sourceHeight, detectionResult) => {\r\n        const sourceAspect = sourceWidth / sourceHeight\r\n        const targetAspect = this.width / this.height\r\n\r\n        let resizeWidth, resizeHeight\r\n\r\n        if (this.preserveAspectRatio) {\r\n            // Calculate scale to fit target aspect ratio\r\n            const scale = Math.max(this.width / sourceWidth, this.height / sourceHeight)\r\n            resizeWidth = Math.round(sourceWidth * scale)\r\n            resizeHeight = Math.round(sourceHeight * scale)\r\n        } else {\r\n            resizeWidth = this.width\r\n            resizeHeight = this.height\r\n        }\r\n\r\n        const requiresUpscaling = resizeWidth > sourceWidth || resizeHeight > sourceHeight\r\n\r\n        return {\r\n            width: resizeWidth,\r\n            height: resizeHeight,\r\n            sourceAspect,\r\n            targetAspect,\r\n            scale: resizeWidth / sourceWidth,\r\n            requiresUpscaling,\r\n            fitsTargetAspect: Math.abs(sourceAspect - targetAspect) < 0.01\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate smart crop area\r\n     * @private\r\n     */\r\n    _calculateSmartCropArea = (detectionResult, resizeResult, sourceWidth, sourceHeight) => {\r\n        const { focusPoint } = detectionResult\r\n        const { width: resizeWidth, height: resizeHeight, scale } = resizeResult\r\n\r\n        // Convert focus point from normalized coordinates to resize coordinates\r\n        const focusX = focusPoint.x * resizeWidth\r\n        const focusY = focusPoint.y * resizeHeight\r\n\r\n        // Calculate crop area centered on focus point\r\n        let cropX = Math.max(0, Math.min(resizeWidth - this.width, focusX - this.width / 2))\r\n        let cropY = Math.max(0, Math.min(resizeHeight - this.height, focusY - this.height / 2))\r\n\r\n        // Apply rule of thirds adjustment\r\n        const ruleOfThirdsX = Math.round(resizeWidth / 3)\r\n        const ruleOfThirdsY = Math.round(resizeHeight / 3)\r\n\r\n        // Adjust to nearest rule of thirds point\r\n        const thirdsPoints = [\r\n            { x: ruleOfThirdsX, y: ruleOfThirdsY },\r\n            { x: ruleOfThirdsX * 2, y: ruleOfThirdsY },\r\n            { x: ruleOfThirdsX, y: ruleOfThirdsY * 2 },\r\n            { x: ruleOfThirdsX * 2, y: ruleOfThirdsY * 2 }\r\n        ]\r\n\r\n        let bestPoint = { x: cropX + this.width / 2, y: cropY + this.height / 2 }\r\n        let minDistance = Infinity\r\n\r\n        for (const point of thirdsPoints) {\r\n            const distance = Math.sqrt(Math.pow(point.x - focusX, 2) + Math.pow(point.y - focusY, 2))\r\n            if (distance < minDistance) {\r\n                minDistance = distance\r\n                bestPoint = point\r\n            }\r\n        }\r\n\r\n        // Recalculate crop area based on best rule of thirds point\r\n        cropX = Math.max(0, Math.min(resizeWidth - this.width, bestPoint.x - this.width / 2))\r\n        cropY = Math.max(0, Math.min(resizeHeight - this.height, bestPoint.y - this.height / 2))\r\n\r\n        return {\r\n            cropX: Math.round(cropX),\r\n            cropY: Math.round(cropY),\r\n            cropWidth: this.width,\r\n            cropHeight: this.height,\r\n            finalWidth: this.width,\r\n            finalHeight: this.height,\r\n            scale,\r\n            ruleOfThirdsApplied: true,\r\n            focusPoint: { x: focusX, y: focusY },\r\n            adjustedFocusPoint: bestPoint\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate content preservation percentage\r\n     * @private\r\n     */\r\n    _calculateContentPreservation = (detectionResult, cropResult) => {\r\n        if (!detectionResult.faces?.length && !detectionResult.objects?.length) {\r\n            return 100 // No specific content to preserve\r\n        }\r\n\r\n        let totalContentArea = 0\r\n        let preservedContentArea = 0\r\n\r\n        // Calculate faces area\r\n        if (detectionResult.faces?.length) {\r\n            detectionResult.faces.forEach(face => {\r\n                const faceArea = face.boundingBox.width * face.boundingBox.height\r\n                totalContentArea += faceArea\r\n\r\n                // Check if face is within crop area\r\n                const faceCenterX = face.boundingBox.x + face.boundingBox.width / 2\r\n                const faceCenterY = face.boundingBox.y + face.boundingBox.height / 2\r\n\r\n                if (faceCenterX >= cropResult.cropX && faceCenterX <= cropResult.cropX + cropResult.cropWidth &&\r\n                    faceCenterY >= cropResult.cropY && faceCenterY <= cropResult.cropY + cropResult.cropHeight) {\r\n                    preservedContentArea += faceArea\r\n                }\r\n            })\r\n        }\r\n\r\n        // Calculate objects area\r\n        if (detectionResult.objects?.length) {\r\n            detectionResult.objects.forEach(object => {\r\n                const objectArea = object.boundingBox.width * object.boundingBox.height\r\n                totalContentArea += objectArea\r\n\r\n                // Check if object is within crop area\r\n                const objectCenterX = object.boundingBox.x + object.boundingBox.width / 2\r\n                const objectCenterY = object.boundingBox.y + object.boundingBox.height / 2\r\n\r\n                if (objectCenterX >= cropResult.cropX && objectCenterX <= cropResult.cropX + cropResult.cropWidth &&\r\n                    objectCenterY >= cropResult.cropY && objectCenterY <= cropResult.cropY + cropResult.cropHeight) {\r\n                    preservedContentArea += objectArea\r\n                }\r\n            })\r\n        }\r\n\r\n        return totalContentArea > 0 ? Math.round((preservedContentArea / totalContentArea) * 100) : 100\r\n    }\r\n\r\n    /**\r\n     * Add smart crop warnings\r\n     * @private\r\n     */\r\n    _addSmartCropWarnings = (detectionResult, resizeResult, cropResult, result) => {\r\n        const contentPreservation = result.metadata.contentPreserved\r\n\r\n        if (contentPreservation < 80) {\r\n            result.warnings.push({\r\n                type: 'CONTENT_LOSS',\r\n                message: `Only ${contentPreservation}% of detected content preserved in crop`,\r\n                severity: 'warning',\r\n                suggestion: 'Consider adjusting crop dimensions or using different focus point'\r\n            })\r\n        }\r\n\r\n        if (resizeResult.requiresUpscaling && !this.upscale) {\r\n            result.warnings.push({\r\n                type: 'UPSCALING_REQUIRED',\r\n                message: 'Crop requires upscaling but upscale is disabled',\r\n                severity: 'info',\r\n                suggestion: 'Enable upscaling or use smaller crop dimensions'\r\n            })\r\n        }\r\n\r\n        if (detectionResult.usingFallback) {\r\n            result.warnings.push({\r\n                type: 'AI_FALLBACK_USED',\r\n                message: 'AI detection failed, using fallback crop method',\r\n                severity: 'info',\r\n                suggestion: 'Check image quality or adjust confidence threshold'\r\n            })\r\n        }\r\n    }\r\n\r\n    /**\r\n     * STEP 1: Detect region of interest using AI/computer vision\r\n     * @private\r\n     */\r\n    _detectRegionOfInterest = async (lemGendImage) => {\r\n        const result = {\r\n            faces: [],\r\n            objects: [],\r\n            saliencyArea: null,\r\n            entropyMap: null,\r\n            focusPoint: { x: 0.5, y: 0.5 }, // Default center\r\n            confidence: 0,\r\n            capabilitiesUsed: []\r\n        }\r\n\r\n        try {\r\n            // Validate AI capabilities first\r\n            if (!this.aiCapabilities) {\r\n                this.aiCapabilities = await this._checkAICapabilities()\r\n            }\r\n\r\n            // Load the image for analysis\r\n            const imageBitmap = await createImageBitmap(lemGendImage.file)\r\n\r\n            // Execute detection based on mode and available capabilities\r\n            if (this.mode === 'face' || this.mode === 'smart') {\r\n                if (this.aiCapabilities.faceDetection) {\r\n                    result.faces = await this._detectFaces(imageBitmap)\r\n                    if (result.faces.length > 0) {\r\n                        result.focusPoint = this._calculateFaceCenter(result.faces)\r\n                        result.confidence = Math.max(...result.faces.map(f => f.confidence))\r\n                        result.capabilitiesUsed.push('face-detection')\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.mode === 'object' || this.mode === 'smart') {\r\n                if (this.aiCapabilities.objectDetection) {\r\n                    result.objects = await this._detectObjects(imageBitmap)\r\n                    if (result.objects.length > 0) {\r\n                        result.focusPoint = this._calculateObjectCenter(result.objects)\r\n                        result.confidence = Math.max(...result.objects.map(o => o.confidence))\r\n                        result.capabilitiesUsed.push('object-detection')\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.mode === 'saliency' || this.mode === 'smart') {\r\n                if (this.aiCapabilities.saliencyDetection) {\r\n                    result.saliencyArea = await this._detectSaliency(imageBitmap)\r\n                    if (result.saliencyArea) {\r\n                        result.focusPoint = result.saliencyArea.center\r\n                        result.confidence = result.saliencyArea.confidence\r\n                        result.capabilitiesUsed.push('saliency-detection')\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.mode === 'entropy' || this.mode === 'smart') {\r\n                if (this.aiCapabilities.entropyDetection) {\r\n                    result.entropyMap = await this._calculateEntropy(imageBitmap)\r\n                    if (result.entropyMap) {\r\n                        result.focusPoint = result.entropyMap.highestEntropyPoint\r\n                        result.confidence = result.entropyMap.confidence\r\n                        result.capabilitiesUsed.push('entropy-analysis')\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback to center if no detection or low confidence\r\n            if (result.confidence < this.confidenceThreshold / 100) {\r\n                console.log('Low confidence detection, using center focus')\r\n                result.focusPoint = { x: 0.5, y: 0.5 }\r\n                result.confidence = 0.5\r\n                result.capabilitiesUsed.push('fallback-center')\r\n            }\r\n\r\n            // Clean up\r\n            imageBitmap.close()\r\n\r\n        } catch (error) {\r\n            console.warn('AI detection failed:', error.message)\r\n            result.focusPoint = { x: 0.5, y: 0.5 }\r\n            result.confidence = 0.5\r\n            result.capabilitiesUsed.push('error-fallback')\r\n            result.error = error.message\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Detect faces in image with error handling\r\n     * @private\r\n     */\r\n    _detectFaces = async (imageBitmap) => {\r\n        const faces = []\r\n\r\n        try {\r\n            if (typeof FaceDetector !== 'undefined') {\r\n                const faceDetector = new FaceDetector({\r\n                    maxDetectedFaces: this.multipleFaces ? 10 : 1,\r\n                    fastMode: true\r\n                })\r\n\r\n                const detectedFaces = await faceDetector.detect(imageBitmap)\r\n\r\n                faces.push(...detectedFaces.map(face => ({\r\n                    boundingBox: face.boundingBox,\r\n                    confidence: face.confidence || 0.8,\r\n                    landmarks: face.landmarks || [],\r\n                    type: 'face'\r\n                })))\r\n            }\r\n        } catch (error) {\r\n            console.warn('Face detection failed:', error.message)\r\n            // Don't throw, just return empty array\r\n        }\r\n\r\n        return faces\r\n    }\r\n\r\n    /**\r\n     * Calculate face center from multiple faces\r\n     * @private\r\n     */\r\n    _calculateFaceCenter = (faces) => {\r\n        if (!faces.length) return { x: 0.5, y: 0.5 }\r\n\r\n        let totalX = 0\r\n        let totalY = 0\r\n        let totalWeight = 0\r\n\r\n        faces.forEach(face => {\r\n            const weight = face.confidence || 0.5\r\n            const centerX = face.boundingBox.x + face.boundingBox.width / 2\r\n            const centerY = face.boundingBox.y + face.boundingBox.height / 2\r\n\r\n            totalX += centerX * weight\r\n            totalY += centerY * weight\r\n            totalWeight += weight\r\n        })\r\n\r\n        return {\r\n            x: totalWeight > 0 ? totalX / totalWeight : 0.5,\r\n            y: totalWeight > 0 ? totalY / totalWeight : 0.5\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detect objects in image (simulated fallback)\r\n     * @private\r\n     */\r\n    _detectObjects = async (imageBitmap) => {\r\n        // Simulated object detection - in real implementation, use TensorFlow.js COCO-SSD\r\n        const objects = []\r\n\r\n        try {\r\n            if (typeof tf !== 'undefined') {\r\n                // This is where TensorFlow.js object detection would go\r\n                // For now, return empty array as simulation\r\n                console.log('TensorFlow.js object detection would run here')\r\n            }\r\n        } catch (error) {\r\n            console.warn('Object detection failed:', error.message)\r\n        }\r\n\r\n        return objects\r\n    }\r\n\r\n    /**\r\n     * Calculate object center\r\n     * @private\r\n     */\r\n    _calculateObjectCenter = (objects) => {\r\n        if (!objects.length) return { x: 0.5, y: 0.5 }\r\n\r\n        let totalX = 0\r\n        let totalY = 0\r\n        let totalWeight = 0\r\n\r\n        objects.forEach(object => {\r\n            const weight = object.confidence || 0.5\r\n            const centerX = object.boundingBox.x + object.boundingBox.width / 2\r\n            const centerY = object.boundingBox.y + object.boundingBox.height / 2\r\n\r\n            totalX += centerX * weight\r\n            totalY += centerY * weight\r\n            totalWeight += weight\r\n        })\r\n\r\n        return {\r\n            x: totalWeight > 0 ? totalX / totalWeight : 0.5,\r\n            y: totalWeight > 0 ? totalY / totalWeight : 0.5\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detect saliency (simulated fallback)\r\n     * @private\r\n     */\r\n    _detectSaliency = async (imageBitmap) => {\r\n        // Simulated saliency detection\r\n        return {\r\n            center: { x: 0.5, y: 0.5 },\r\n            confidence: 0.6,\r\n            method: 'simulated'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate entropy (simulated fallback)\r\n     * @private\r\n     */\r\n    _calculateEntropy = async (imageBitmap) => {\r\n        // Simulated entropy calculation\r\n        return {\r\n            highestEntropyPoint: { x: 0.5, y: 0.5 },\r\n            confidence: 0.7,\r\n            method: 'simulated'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple crop algorithm (static method)\r\n     * @static\r\n     */\r\n    static simpleCrop(sourceWidth, sourceHeight, targetWidth, targetHeight, mode = 'center') {\r\n        const scale = Math.max(targetWidth / sourceWidth, targetHeight / sourceHeight)\r\n        const scaledWidth = Math.round(sourceWidth * scale)\r\n        const scaledHeight = Math.round(sourceHeight * scale)\r\n\r\n        let cropX, cropY\r\n\r\n        switch (mode) {\r\n            case 'top':\r\n                cropX = (scaledWidth - targetWidth) / 2\r\n                cropY = 0\r\n                break\r\n            case 'bottom':\r\n                cropX = (scaledWidth - targetWidth) / 2\r\n                cropY = scaledHeight - targetHeight\r\n                break\r\n            case 'left':\r\n                cropX = 0\r\n                cropY = (scaledHeight - targetHeight) / 2\r\n                break\r\n            case 'right':\r\n                cropX = scaledWidth - targetWidth\r\n                cropY = (scaledHeight - targetHeight) / 2\r\n                break\r\n            case 'top-left':\r\n                cropX = 0\r\n                cropY = 0\r\n                break\r\n            case 'top-right':\r\n                cropX = scaledWidth - targetWidth\r\n                cropY = 0\r\n                break\r\n            case 'bottom-left':\r\n                cropX = 0\r\n                cropY = scaledHeight - targetHeight\r\n                break\r\n            case 'bottom-right':\r\n                cropX = scaledWidth - targetWidth\r\n                cropY = scaledHeight - targetHeight\r\n                break\r\n            case 'center':\r\n            default:\r\n                cropX = (scaledWidth - targetWidth) / 2\r\n                cropY = (scaledHeight - targetHeight) / 2\r\n        }\r\n\r\n        return {\r\n            cropX: Math.max(0, Math.round(cropX)),\r\n            cropY: Math.max(0, Math.round(cropY)),\r\n            cropWidth: targetWidth,\r\n            cropHeight: targetHeight,\r\n            scale,\r\n            scaledWidth,\r\n            scaledHeight,\r\n            mode\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get processor description\r\n     * @returns {string} Description\r\n     */\r\n    static getDescription() {\r\n        return 'LemGendaryCrop™: AI-powered smart cropping with enhanced validation, fallback handling, and detailed capability reporting.'\r\n    }\r\n\r\n    /**\r\n     * Get processor information\r\n     * @returns {Object} Processor info\r\n     */\r\n    static getInfo() {\r\n        return {\r\n            name: 'LemGendaryCrop',\r\n            version: '3.0.0',\r\n            description: this.getDescription(),\r\n            modes: ['smart', 'face', 'object', 'saliency', 'entropy', 'center', 'top', 'bottom', 'left', 'right'],\r\n            features: [\r\n                'Enhanced validation system',\r\n                'AI capability detection',\r\n                'Graceful fallback handling',\r\n                'Face detection',\r\n                'Object detection',\r\n                'Saliency detection',\r\n                'Entropy calculation',\r\n                'Rule of thirds alignment',\r\n                'Content-aware resizing',\r\n                'SVG/ICO support',\r\n                'Batch processing'\r\n            ],\r\n            requirements: {\r\n                faceDetection: 'FaceDetector API',\r\n                objectDetection: 'TensorFlow.js',\r\n                saliencyDetection: 'Canvas API',\r\n                minimumBrowser: 'Chrome 94+, Firefox 92+, Safari 15.4+'\r\n            },\r\n            validationLevel: 'enhanced'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate if processor can handle given image\r\n     * @param {LemGendImage} image - Image to check\r\n     * @returns {Object} Validation result\r\n     */\r\n    static async canProcess(image) {\r\n        const processor = new LemGendaryCrop()\r\n\r\n        try {\r\n            await processor._validateOptions()\r\n            const imageValidation = processor._validateImage(image)\r\n            const capabilities = await processor._checkAICapabilities()\r\n\r\n            return {\r\n                canProcess: imageValidation.canProcess,\r\n                reason: imageValidation.canProcess ? 'Image can be processed' : imageValidation.errors.join(', '),\r\n                warnings: imageValidation.warnings,\r\n                aiCapabilities: capabilities.summary,\r\n                supportedModes: capabilities.hasAnyAI ?\r\n                    ['smart', 'face', 'object', 'saliency', 'entropy', 'center', 'top', 'bottom', 'left', 'right'] :\r\n                    ['center', 'top', 'bottom', 'left', 'right'],\r\n                enhancedValidation: true\r\n            }\r\n        } catch (error) {\r\n            return {\r\n                canProcess: false,\r\n                reason: error.message,\r\n                warnings: [],\r\n                aiCapabilities: null,\r\n                enhancedValidation: true\r\n            }\r\n        }\r\n    }\r\n}","/**\r\n * LemGendaryOptimize™ - Advanced image optimization processor\r\n * @class\r\n * @description Optimizes images with intelligent format selection, adaptive compression, and pre-ZIP optimization\r\n */\r\nexport class LemGendaryOptimize {\r\n    /**\r\n     * Create a LemGendaryOptimize processor\r\n     * @param {Object} options - Optimization options\r\n     * @param {number} options.quality - Quality percentage (1-100)\r\n     * @param {string} options.format - Output format: 'auto', 'webp', 'jpg', 'png', 'avif', 'ico', 'svg', 'original'\r\n     * @param {boolean} options.lossless - Use lossless compression (for PNG/WebP)\r\n     * @param {boolean} options.stripMetadata - Remove metadata (EXIF, etc.)\r\n     * @param {boolean} options.preserveTransparency - Preserve transparency when possible\r\n     * @param {Array<number>} options.icoSizes - Specific sizes for ICO format\r\n     * @param {number} options.maxDisplayWidth - Maximum display width for optimization (optional)\r\n     * @param {Array} options.browserSupport - Browser support requirements ['modern', 'legacy']\r\n     * @param {string} options.compressionMode - 'adaptive', 'aggressive', 'balanced'\r\n     * @param {boolean} options.analyzeContent - Enable content analysis for smart optimization\r\n     */\r\n    constructor(options = {}) {\r\n        // Core optimization options\r\n        this.quality = Math.max(1, Math.min(100, options.quality || 85))\r\n        this.format = options.format || 'auto'\r\n        this.lossless = options.lossless || false\r\n        this.stripMetadata = options.stripMetadata !== false\r\n        this.preserveTransparency = options.preserveTransparency !== false\r\n        this.icoSizes = options.icoSizes || [16, 32, 48, 64, 128, 256]\r\n\r\n        // Advanced optimization options\r\n        this.maxDisplayWidth = options.maxDisplayWidth || null\r\n        this.browserSupport = options.browserSupport || ['modern', 'legacy']\r\n        this.compressionMode = options.compressionMode || 'adaptive'\r\n        this.analyzeContent = options.analyzeContent !== false\r\n\r\n        this.name = 'LemGendaryOptimize'\r\n        this.version = '2.0.0' // Updated version\r\n\r\n        // Format priorities for intelligent selection\r\n        this.formatPriorities = this._getFormatPriorities()\r\n    }\r\n\r\n    /**\r\n     * Get format priorities based on browser support\r\n     * @private\r\n     */\r\n    _getFormatPriorities() {\r\n        const formats = {\r\n            'avif': {\r\n                quality: 0.9,\r\n                browserSupport: this.browserSupport.includes('modern') ? 0.9 : 0.7,\r\n                compression: 0.8,\r\n                supportsTransparency: true,\r\n                maxQuality: 63 // AVIF has different quality scale\r\n            },\r\n            'webp': {\r\n                quality: 0.8,\r\n                browserSupport: this.browserSupport.includes('legacy') ? 0.9 : 0.98,\r\n                compression: 0.7,\r\n                supportsTransparency: true,\r\n                maxQuality: 100\r\n            },\r\n            'jpg': {\r\n                quality: 0.7,\r\n                browserSupport: 1.0,\r\n                compression: 0.6,\r\n                supportsTransparency: false,\r\n                maxQuality: 100\r\n            },\r\n            'png': {\r\n                quality: 0.9,\r\n                browserSupport: 1.0,\r\n                compression: 0.5,\r\n                supportsTransparency: true,\r\n                maxQuality: 100\r\n            },\r\n            'ico': {\r\n                quality: 1.0,\r\n                browserSupport: 1.0,\r\n                compression: 0.5,\r\n                supportsTransparency: true,\r\n                maxQuality: 100\r\n            }\r\n        }\r\n\r\n        return formats\r\n    }\r\n\r\n    /**\r\n    * Validate processor options using enhanced validation\r\n    * @private\r\n    */\r\n    _validateOptions = () => {\r\n        // Import validation function dynamically\r\n        let validation\r\n        try {\r\n            // Try to import from validation.js\r\n            validation = require('./validation.js').validateOptimizationOptions\r\n        } catch {\r\n            // Fallback to basic validation\r\n            validation = this._basicValidateOptimizationOptions\r\n        }\r\n\r\n        const validationResult = validation({\r\n            format: this.format,\r\n            quality: this.quality,\r\n            maxDisplayWidth: this.maxDisplayWidth,\r\n            browserSupport: this.browserSupport,\r\n            compressionMode: this.compressionMode,\r\n            stripMetadata: this.stripMetadata,\r\n            preserveTransparency: this.preserveTransparency,\r\n            lossless: this.lossless,\r\n            icoSizes: this.icoSizes\r\n        })\r\n\r\n        if (!validationResult.valid) {\r\n            const errorMessages = validationResult.errors.map(e => e.message).join(', ')\r\n            throw new Error(`Invalid optimization options: ${errorMessages}`)\r\n        }\r\n\r\n        // Show warnings if any\r\n        if (validationResult.warnings.length > 0) {\r\n            console.warn('Optimization warnings:', validationResult.warnings.map(w => w.message))\r\n        }\r\n\r\n        // Adjust quality for specific formats\r\n        if (this.format === 'avif') {\r\n            this.quality = Math.min(63, Math.round(this.quality * 0.63))\r\n        }\r\n\r\n        if (this.format === 'png' && this.preserveTransparency) {\r\n            this.lossless = true\r\n        }\r\n\r\n        if (this.format === 'ico') {\r\n            this.icoSizes.sort((a, b) => a - b)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Basic validation fallback\r\n     * @private\r\n     */\r\n    _basicValidateOptimizationOptions = (options) => {\r\n        const errors = []\r\n        const warnings = []\r\n\r\n        // Basic validation\r\n        if (options.quality < 1 || options.quality > 100) {\r\n            errors.push({\r\n                code: 'INVALID_QUALITY',\r\n                message: `Quality must be between 1-100, got ${options.quality}`,\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        const validFormats = ['auto', 'webp', 'jpg', 'jpeg', 'png', 'avif', 'ico', 'svg', 'original']\r\n        if (!validFormats.includes(options.format)) {\r\n            errors.push({\r\n                code: 'INVALID_FORMAT',\r\n                message: `Invalid format: ${options.format}`,\r\n                severity: 'error'\r\n            })\r\n        }\r\n\r\n        return { valid: errors.length === 0, errors, warnings }\r\n    }\r\n\r\n    /**\r\n     * Analyze image metadata and content for intelligent optimization\r\n     * @private\r\n     */\r\n    async _analyzeImage(lemGendImage) {\r\n        const analysis = {\r\n            metadata: {\r\n                width: lemGendImage.width,\r\n                height: lemGendImage.height,\r\n                aspectRatio: lemGendImage.aspectRatio,\r\n                orientation: lemGendImage.orientation,\r\n                hasTransparency: lemGendImage.transparency,\r\n                fileSize: lemGendImage.originalSize,\r\n                format: lemGendImage.extension,\r\n                mimeType: lemGendImage.type,\r\n                isFavicon: lemGendImage.type.includes('icon') || lemGendImage.extension === 'ico'\r\n            },\r\n            content: {\r\n                isPhotographic: this._guessIsPhotographic(lemGendImage),\r\n                hasText: false,\r\n                isGraphic: this._guessIsGraphic(lemGendImage),\r\n                complexity: 'medium'\r\n            },\r\n            recommendations: [],\r\n            warnings: []\r\n        }\r\n\r\n        // Content-specific analysis\r\n        if (lemGendImage.type === 'image/svg+xml') {\r\n            analysis.content.isGraphic = true\r\n            analysis.content.complexity = 'low'\r\n            analysis.recommendations.push('SVG format detected - vector graphics optimized differently')\r\n        }\r\n\r\n        if (lemGendImage.transparency) {\r\n            analysis.content.isGraphic = true\r\n            analysis.recommendations.push('Transparency detected - PNG or WebP recommended')\r\n        }\r\n\r\n        // Size-based analysis\r\n        if (lemGendImage.width > 2000 || lemGendImage.height > 2000) {\r\n            analysis.recommendations.push('Large dimensions - consider resizing for web use')\r\n        }\r\n\r\n        if (lemGendImage.originalSize > 1024 * 1024) {\r\n            analysis.recommendations.push('Large file size - significant compression possible')\r\n        }\r\n\r\n        // Compatibility warnings\r\n        if (this.format === 'jpg' && lemGendImage.transparency) {\r\n            analysis.warnings.push({\r\n                type: 'transparency_loss',\r\n                message: 'JPEG format will remove transparency',\r\n                severity: 'warning'\r\n            })\r\n        }\r\n\r\n        return analysis\r\n    }\r\n\r\n    /**\r\n     * Guess if image is photographic\r\n     * @private\r\n     */\r\n    _guessIsPhotographic(lemGendImage) {\r\n        // Simple heuristic based on aspect ratio and size\r\n        const { width, height } = lemGendImage\r\n        const aspectRatio = width / height\r\n\r\n        // Common photographic aspect ratios\r\n        const photoAspectRatios = [3 / 2, 4 / 3, 16 / 9, 1, 5 / 4]\r\n\r\n        const isCloseToPhotoRatio = photoAspectRatios.some(ratio =>\r\n            Math.abs(aspectRatio - ratio) < 0.1\r\n        )\r\n\r\n        return isCloseToPhotoRatio && (width * height) > 500000\r\n    }\r\n\r\n    /**\r\n     * Guess if image is graphic/illustration\r\n     * @private\r\n     */\r\n    _guessIsGraphic(lemGendImage) {\r\n        return lemGendImage.type === 'image/svg+xml' ||\r\n            lemGendImage.transparency ||\r\n            (lemGendImage.width <= 1000 && lemGendImage.height <= 1000)\r\n    }\r\n\r\n    /**\r\n     * Intelligent format selection when 'auto' is specified\r\n     * @private\r\n     */\r\n    _selectBestFormat(analysis) {\r\n        if (this.format !== 'auto') {\r\n            return this.format\r\n        }\r\n\r\n        const scores = {}\r\n        const { hasTransparency, isFavicon } = analysis.metadata\r\n        const { isGraphic } = analysis.content\r\n        const { width, height } = analysis.metadata\r\n\r\n        // Don't auto-select ICO for non-favicon images\r\n        const availableFormats = isFavicon ?\r\n            ['ico', 'png', 'webp'] :\r\n            ['webp', 'avif', 'jpg', 'png']\r\n\r\n        for (const format of availableFormats) {\r\n            const data = this.formatPriorities[format]\r\n            if (!data) continue\r\n\r\n            let score = data.browserSupport * 0.4 + data.compression * 0.3 + data.quality * 0.3\r\n\r\n            // Adjust based on image characteristics\r\n            if (hasTransparency && !data.supportsTransparency) {\r\n                score *= 0.3\r\n            }\r\n\r\n            if (isGraphic && format === 'png') {\r\n                score *= 1.3\r\n            }\r\n\r\n            if (width * height > 2000000 && format === 'avif') {\r\n                score *= 1.2\r\n            }\r\n\r\n            if (isFavicon && format === 'ico') {\r\n                score *= 2.0 // Strong preference for ICO for favicons\r\n            }\r\n\r\n            scores[format] = score\r\n        }\r\n\r\n        // Return best scoring format, default to webp if none found\r\n        const bestFormat = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b)\r\n        return bestFormat || 'webp'\r\n    }\r\n\r\n    /**\r\n     * Calculate adaptive compression settings\r\n     * @private\r\n     */\r\n    _calculateCompression(analysis, selectedFormat) {\r\n        let quality = this.quality\r\n        let compressionLevel = 'balanced'\r\n        let lossless = this.lossless\r\n\r\n        const { hasTransparency } = analysis.metadata\r\n        const { isGraphic, isPhotographic } = analysis.content\r\n\r\n        // Adjust for format-specific quality scales\r\n        const formatData = this.formatPriorities[selectedFormat]\r\n        if (formatData && formatData.maxQuality) {\r\n            quality = Math.min(quality, formatData.maxQuality)\r\n        }\r\n\r\n        // Content-based adjustments\r\n        if (isGraphic && selectedFormat === 'png') {\r\n            lossless = true\r\n            quality = 100\r\n        } else if (isPhotographic && selectedFormat === 'jpg') {\r\n            quality = Math.max(75, quality)\r\n        }\r\n\r\n        // Compression mode adjustments\r\n        switch (this.compressionMode) {\r\n            case 'aggressive':\r\n                quality = Math.max(60, quality * 0.8)\r\n                compressionLevel = 'high'\r\n                break\r\n            case 'balanced':\r\n                compressionLevel = 'medium'\r\n                break\r\n            case 'adaptive':\r\n                const megapixels = (analysis.metadata.width * analysis.metadata.height) / 1000000\r\n                if (megapixels > 2) {\r\n                    quality = Math.max(70, quality * 0.9)\r\n                    compressionLevel = 'high'\r\n                }\r\n                break\r\n        }\r\n\r\n        // Ensure transparency compatibility\r\n        if (hasTransparency && selectedFormat === 'jpg') {\r\n            quality = Math.max(85, quality) // Higher quality to minimize artifacts\r\n        }\r\n\r\n        return {\r\n            quality: Math.round(quality),\r\n            compressionLevel,\r\n            lossless: selectedFormat === 'png' && lossless,\r\n            progressive: selectedFormat === 'jpg' || selectedFormat === 'webp',\r\n            preserveTransparency: hasTransparency && this.preserveTransparency\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate resizing if maxDisplayWidth is set\r\n     * @private\r\n     */\r\n    _calculateResizeDimensions(analysis) {\r\n        if (!this.maxDisplayWidth) {\r\n            return null\r\n        }\r\n\r\n        const { width, height } = analysis.metadata\r\n\r\n        if (width <= this.maxDisplayWidth && height <= this.maxDisplayWidth) {\r\n            return null\r\n        }\r\n\r\n        let newWidth, newHeight\r\n\r\n        if (width >= height) {\r\n            // Landscape or square\r\n            newWidth = Math.min(width, this.maxDisplayWidth)\r\n            newHeight = Math.round((height / width) * newWidth)\r\n        } else {\r\n            // Portrait\r\n            newHeight = Math.min(height, this.maxDisplayWidth)\r\n            newWidth = Math.round((width / height) * newHeight)\r\n        }\r\n\r\n        // Ensure minimum dimensions\r\n        const minDimension = 100\r\n        if (newWidth < minDimension) newWidth = minDimension\r\n        if (newHeight < minDimension) newHeight = minDimension\r\n\r\n        return {\r\n            width: newWidth,\r\n            height: newHeight,\r\n            originalWidth: width,\r\n            originalHeight: height,\r\n            resizeRatio: newWidth / width,\r\n            resizeNeeded: true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check format compatibility\r\n     * @private\r\n     */\r\n    _checkCompatibility = (image, selectedFormat) => {\r\n        const supportedFormats = {\r\n            'jpg': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif', 'image/bmp', 'image/x-icon'],\r\n            'jpeg': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif', 'image/bmp', 'image/x-icon'],\r\n            'png': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif', 'image/bmp', 'image/svg+xml', 'image/x-icon'],\r\n            'webp': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif', 'image/bmp', 'image/svg+xml', 'image/x-icon'],\r\n            'avif': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/x-icon'],\r\n            'ico': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/bmp', 'image/x-icon'],\r\n            'svg': ['image/svg+xml', 'image/png', 'image/webp'],\r\n            'original': ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif', 'image/bmp', 'image/svg+xml', 'image/x-icon']\r\n        }\r\n\r\n        const canConvert = supportedFormats[selectedFormat]?.includes(image.type) || false\r\n\r\n        return {\r\n            compatible: canConvert,\r\n            reason: canConvert ? 'Format supported' : `Cannot convert ${image.type} to ${selectedFormat}`,\r\n            requiresRasterization: (image.type === 'image/svg+xml' && selectedFormat !== 'original' && selectedFormat !== 'svg'),\r\n            requiresFaviconProcessing: selectedFormat === 'ico'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Estimate file size savings\r\n     * @private\r\n     */\r\n    _estimateSavings(analysis, selectedFormat, compression, resizeInfo) {\r\n        const originalSize = analysis.metadata.fileSize\r\n        let estimatedSize = originalSize\r\n\r\n        // Apply format compression\r\n        const formatData = this.formatPriorities[selectedFormat]\r\n        if (formatData) {\r\n            estimatedSize *= formatData.compression\r\n        }\r\n\r\n        // Apply quality adjustment\r\n        estimatedSize *= (compression.quality / 100)\r\n\r\n        // Apply resize reduction if applicable\r\n        if (resizeInfo && resizeInfo.resizeNeeded) {\r\n            const areaReduction = (resizeInfo.width * resizeInfo.height) /\r\n                (analysis.metadata.width * analysis.metadata.height)\r\n            estimatedSize *= areaReduction\r\n        }\r\n\r\n        // Apply compression mode adjustment\r\n        if (compression.compressionLevel === 'high') {\r\n            estimatedSize *= 0.9\r\n        } else if (compression.compressionLevel === 'medium') {\r\n            estimatedSize *= 0.95\r\n        }\r\n\r\n        // Apply transparency factor\r\n        if (analysis.metadata.hasTransparency && selectedFormat !== 'jpg') {\r\n            estimatedSize *= 1.1\r\n        }\r\n\r\n        const savings = {\r\n            originalSize,\r\n            estimatedSize: Math.round(estimatedSize),\r\n            savings: originalSize - Math.round(estimatedSize),\r\n            savingsPercent: Math.round(((originalSize - estimatedSize) / originalSize) * 1000) / 10,\r\n            compressionRatio: (originalSize / estimatedSize).toFixed(2)\r\n        }\r\n\r\n        return savings\r\n    }\r\n\r\n    /**\r\n     * Process an image with optimization\r\n     * @param {LemGendImage} lemGendImage - Image to process\r\n     * @returns {Promise<Object>} Optimization result\r\n     */\r\n    process = async (lemGendImage) => {\r\n        this._validateOptions()\r\n\r\n        if (!lemGendImage) {\r\n            throw new Error('Invalid image')\r\n        }\r\n\r\n        // Step 1: Analyze image\r\n        const analysis = await this._analyzeImage(lemGendImage)\r\n\r\n        // Step 2: Select format\r\n        const selectedFormat = this._selectBestFormat(analysis)\r\n\r\n        // Step 3: Check compatibility\r\n        const compatibility = this._checkCompatibility(lemGendImage, selectedFormat)\r\n        if (!compatibility.compatible) {\r\n            throw new Error(`Format not compatible: ${compatibility.reason}`)\r\n        }\r\n\r\n        // Step 4: Calculate resize\r\n        const resizeInfo = this._calculateResizeDimensions(analysis)\r\n\r\n        // Step 5: Calculate compression\r\n        const compression = this._calculateCompression(analysis, selectedFormat)\r\n\r\n        // Step 6: Estimate savings\r\n        const savings = this._estimateSavings(analysis, selectedFormat, compression, resizeInfo)\r\n\r\n        const result = {\r\n            success: true,\r\n            operation: this.name,\r\n            originalInfo: {\r\n                ...analysis.metadata,\r\n                name: lemGendImage.originalName\r\n            },\r\n            optimization: {\r\n                selectedFormat: selectedFormat === 'original' ? lemGendImage.extension : selectedFormat,\r\n                compression,\r\n                resizeInfo,\r\n                browserSupport: this.browserSupport,\r\n                compressionMode: this.compressionMode,\r\n                compatibility,\r\n                recommendedForWeb: this._isRecommendedForWeb(analysis, selectedFormat)\r\n            },\r\n            analysis,\r\n            savings,\r\n            recommendations: analysis.recommendations,\r\n            warnings: analysis.warnings,\r\n            metadata: {\r\n                processedAt: new Date().toISOString(),\r\n                processorVersion: this.version,\r\n                optimizationLevel: this._getOptimizationLevel(compression, savings)\r\n            }\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Determine if format is recommended for web\r\n     * @private\r\n     */\r\n    _isRecommendedForWeb(analysis, format) {\r\n        const webRecommended = ['webp', 'avif', 'jpg', 'png']\r\n        return webRecommended.includes(format) &&\r\n            analysis.metadata.fileSize < 5000000 // Less than 5MB\r\n    }\r\n\r\n    /**\r\n     * Get optimization level\r\n     * @private\r\n     */\r\n    _getOptimizationLevel(compression, savings) {\r\n        if (savings.savingsPercent > 70) return 'high'\r\n        if (savings.savingsPercent > 40) return 'medium'\r\n        return 'low'\r\n    }\r\n\r\n    /**\r\n     * Apply optimization to create optimized file (for ZIP preparation)\r\n     * @param {LemGendImage} lemGendImage - Image to optimize\r\n     * @returns {Promise<File>} Optimized file\r\n     */\r\n    async applyOptimization(lemGendImage) {\r\n        const result = await this.process(lemGendImage)\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image()\r\n\r\n            img.onload = () => {\r\n                try {\r\n                    const canvas = document.createElement('canvas')\r\n                    const ctx = canvas.getContext('2d')\r\n\r\n                    // Set dimensions\r\n                    let width = img.width\r\n                    let height = img.height\r\n\r\n                    if (result.optimization.resizeInfo && result.optimization.resizeInfo.resizeNeeded) {\r\n                        width = result.optimization.resizeInfo.width\r\n                        height = result.optimization.resizeInfo.height\r\n                    }\r\n\r\n                    canvas.width = width\r\n                    canvas.height = height\r\n\r\n                    // Handle transparency/background\r\n                    const format = result.optimization.selectedFormat\r\n                    const hasTransparency = result.originalInfo.hasTransparency\r\n\r\n                    if ((format === 'jpg' || format === 'jpeg') && !hasTransparency) {\r\n                        ctx.fillStyle = '#ffffff'\r\n                        ctx.fillRect(0, 0, width, height)\r\n                    }\r\n\r\n                    // Draw image\r\n                    ctx.drawImage(img, 0, 0, width, height)\r\n\r\n                    // Determine MIME type\r\n                    let mimeType\r\n                    switch (format) {\r\n                        case 'webp': mimeType = 'image/webp'; break\r\n                        case 'avif': mimeType = 'image/avif'; break\r\n                        case 'jpg':\r\n                        case 'jpeg': mimeType = 'image/jpeg'; break\r\n                        case 'png': mimeType = 'image/png'; break\r\n                        case 'ico': mimeType = 'image/x-icon'; break\r\n                        default: mimeType = 'image/webp'\r\n                    }\r\n\r\n                    // Apply quality\r\n                    const quality = result.optimization.compression.quality / 100\r\n\r\n                    canvas.toBlob(\r\n                        (blob) => {\r\n                            if (!blob) {\r\n                                reject(new Error('Failed to create blob'))\r\n                                return\r\n                            }\r\n\r\n                            const extension = format\r\n                            const originalName = lemGendImage.originalName.replace(/\\.[^/.]+$/, '')\r\n                            const newName = `${originalName}-optimized.${extension}`\r\n\r\n                            resolve(new File([blob], newName, { type: mimeType }))\r\n                        },\r\n                        mimeType,\r\n                        quality\r\n                    )\r\n                } catch (error) {\r\n                    reject(error)\r\n                }\r\n            }\r\n\r\n            img.onerror = () => reject(new Error('Failed to load image'))\r\n            img.src = URL.createObjectURL(lemGendImage.file)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Prepare images for ZIP with optimization\r\n     * @param {Array<LemGendImage>} images - Images to prepare\r\n     * @returns {Promise<Array>} Prepared images with optimization results\r\n     */\r\n    async prepareForZip(images) {\r\n        const results = []\r\n\r\n        for (const image of images) {\r\n            try {\r\n                const optimizationResult = await this.process(image)\r\n                const optimizedFile = await this.applyOptimization(image)\r\n\r\n                results.push({\r\n                    original: image,\r\n                    optimized: optimizedFile,\r\n                    result: optimizationResult,\r\n                    success: true\r\n                })\r\n            } catch (error) {\r\n                results.push({\r\n                    original: image,\r\n                    error: error.message,\r\n                    success: false\r\n                })\r\n            }\r\n        }\r\n\r\n        return results\r\n    }\r\n\r\n    /**\r\n     * Generate optimization report\r\n     * @param {Array} optimizationResults - Results from prepareForZip\r\n     * @returns {Object} Optimization report\r\n     */\r\n    generateOptimizationReport(optimizationResults) {\r\n        const successful = optimizationResults.filter(r => r.success)\r\n        const failed = optimizationResults.filter(r => !r.success)\r\n\r\n        const totalOriginalSize = successful.reduce((sum, r) => sum + r.original.originalSize, 0)\r\n        const totalOptimizedSize = successful.reduce((sum, r) => sum + r.result.savings.estimatedSize, 0)\r\n        const totalSavings = totalOriginalSize - totalOptimizedSize\r\n        const savingsPercentage = (totalSavings / totalOriginalSize * 100).toFixed(1)\r\n\r\n        return {\r\n            summary: {\r\n                totalImages: optimizationResults.length,\r\n                successful: successful.length,\r\n                failed: failed.length,\r\n                totalOriginalSize,\r\n                totalOptimizedSize,\r\n                totalSavings,\r\n                savingsPercentage: `${savingsPercentage}%`,\r\n                averageCompressionRatio: (totalOriginalSize / totalOptimizedSize).toFixed(2),\r\n                generatedAt: new Date().toISOString()\r\n            },\r\n            successfulImages: successful.map(r => ({\r\n                name: r.original.originalName,\r\n                originalSize: r.original.originalSize,\r\n                optimizedSize: r.result.savings.estimatedSize,\r\n                savings: r.result.savings.savings,\r\n                savingsPercent: r.result.savings.savingsPercent,\r\n                format: r.result.optimization.selectedFormat,\r\n                dimensions: `${r.result.originalInfo.width}x${r.result.originalInfo.height}`,\r\n                optimizedDimensions: r.result.optimization.resizeInfo ?\r\n                    `${r.result.optimization.resizeInfo.width}x${r.result.optimization.resizeInfo.height}` :\r\n                    `${r.result.originalInfo.width}x${r.result.originalInfo.height}`\r\n            })),\r\n            failedImages: failed.map(f => ({\r\n                name: f.original.originalName,\r\n                error: f.error\r\n            })),\r\n            recommendations: this._extractRecommendations(successful)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract recommendations from optimization results\r\n     * @private\r\n     */\r\n    _extractRecommendations(successful) {\r\n        const recommendations = []\r\n\r\n        // Check for mixed formats\r\n        const formats = successful.map(r => r.result.optimization.selectedFormat)\r\n        const uniqueFormats = [...new Set(formats)]\r\n\r\n        if (uniqueFormats.length > 2) {\r\n            recommendations.push({\r\n                type: 'format_standardization',\r\n                message: `Multiple formats used: ${uniqueFormats.join(', ')}`,\r\n                suggestion: 'Consider standardizing on 1-2 formats for consistency'\r\n            })\r\n        }\r\n\r\n        // Check for large originals\r\n        const largeOriginals = successful.filter(r =>\r\n            r.original.originalSize > 5 * 1024 * 1024 // > 5MB\r\n        )\r\n\r\n        if (largeOriginals.length > 0) {\r\n            recommendations.push({\r\n                type: 'large_source_files',\r\n                message: `${largeOriginals.length} images were originally very large`,\r\n                suggestion: 'Consider using smaller source images for web'\r\n            })\r\n        }\r\n\r\n        return recommendations\r\n    }\r\n\r\n    /**\r\n     * Get processor description\r\n     * @returns {string} Description\r\n     */\r\n    static getDescription() {\r\n        return 'LemGendaryOptimize™: Advanced image optimization with intelligent format selection, adaptive compression, and ZIP preparation.'\r\n    }\r\n\r\n    /**\r\n     * Get processor information\r\n     * @returns {Object} Processor info\r\n     */\r\n    static getInfo() {\r\n        return {\r\n            name: 'LemGendaryOptimize',\r\n            version: '2.0.0',\r\n            description: this.getDescription(),\r\n            supportedFormats: ['auto', 'webp', 'jpg', 'jpeg', 'png', 'avif', 'ico', 'svg', 'original'],\r\n            features: [\r\n                'Intelligent format selection',\r\n                'Adaptive compression',\r\n                'Content-aware optimization',\r\n                'Browser compatibility analysis',\r\n                'Pre-ZIP optimization',\r\n                'Size estimation',\r\n                'Optimization reporting'\r\n            ],\r\n            optimizationModes: ['adaptive', 'aggressive', 'balanced']\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create processor from configuration object\r\n     * @param {Object} config - Processor configuration\r\n     * @returns {LemGendaryOptimize} New processor instance\r\n     */\r\n    static fromConfig(config) {\r\n        return new LemGendaryOptimize(config)\r\n    }\r\n}","/**\r\n * LemGendaryRename™ - Intelligent rename processor\r\n * @class\r\n * @description Batch rename images with pattern support\r\n */\r\nexport class LemGendaryRename {\r\n    /**\r\n     * Create a LemGendaryRename processor\r\n     * @param {Object} options - Rename options\r\n     * @param {string} options.pattern - Rename pattern\r\n     * @param {number} options.startIndex - Starting index for {index} variable\r\n     * @param {boolean} options.preserveExtension - Keep original file extension\r\n     * @param {string} options.dateFormat - Date format for {date} variable\r\n     * @param {string} options.timeFormat - Time format for {time} variable\r\n     */\r\n    constructor(options = {}) {\r\n        this.pattern = options.pattern || '{name}-{index}'\r\n        this.startIndex = options.startIndex || 1\r\n        this.preserveExtension = options.preserveExtension !== false\r\n        this.dateFormat = options.dateFormat || 'YYYY-MM-DD'\r\n        this.timeFormat = options.timeFormat || 'HH-mm-ss'\r\n        this.name = 'LemGendaryRename'\r\n        this.version = '1.0.0'\r\n    }\r\n\r\n    /**\r\n     * Validate processor options\r\n     * @private\r\n     */\r\n    _validateOptions = () => {\r\n        if (!this.pattern || this.pattern.trim() === '') {\r\n            throw new Error('Rename pattern cannot be empty')\r\n        }\r\n\r\n        const invalidChars = /[<>:\"/\\\\|?*\\x00-\\x1F]/\r\n        if (invalidChars.test(this.pattern)) {\r\n            throw new Error('Pattern contains invalid filename characters')\r\n        }\r\n\r\n        if (typeof this.startIndex !== 'number' || this.startIndex < 0) {\r\n            throw new Error('Start index must be a positive number')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process an image with rename operation\r\n     * @param {LemGendImage} lemGendImage - Image to process\r\n     * @param {number} imageIndex - Index of image in batch\r\n     * @param {number} totalImages - Total number of images\r\n     * @returns {Promise<Object>} Processing result with new filename\r\n     */\r\n    process = async (lemGendImage, imageIndex = 0, totalImages = 1) => {\r\n        this._validateOptions()\r\n\r\n        if (!lemGendImage) {\r\n            throw new Error('Invalid image')\r\n        }\r\n\r\n        const variables = this._generateVariables(lemGendImage, imageIndex)\r\n        const newName = this._applyPattern(this.pattern, variables)\r\n\r\n        const result = {\r\n            success: true,\r\n            operation: this.name,\r\n            originalName: lemGendImage.originalName,\r\n            newName: newName,\r\n            variables: variables,\r\n            settings: {\r\n                pattern: this.pattern,\r\n                startIndex: this.startIndex,\r\n                preserveExtension: this.preserveExtension\r\n            },\r\n            warnings: [],\r\n            recommendations: [],\r\n            metadata: {\r\n                processedAt: new Date().toISOString(),\r\n                patternVariables: Object.keys(variables),\r\n                nameLength: newName.length\r\n            }\r\n        }\r\n\r\n        this._addWarningsAndRecommendations(lemGendImage, newName, result)\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Generate variables for pattern replacement\r\n     * @private\r\n     */\r\n    _generateVariables = (lemGendImage, imageIndex) => {\r\n        const now = new Date()\r\n\r\n        const variables = {\r\n            name: lemGendImage.originalName.replace(/\\.[^/.]+$/, ''),\r\n            originalName: lemGendImage.originalName,\r\n            index: this.startIndex + imageIndex,\r\n            width: lemGendImage.width || 0,\r\n            height: lemGendImage.height || 0,\r\n            dimensions: `${lemGendImage.width || 0}x${lemGendImage.height || 0}`,\r\n            aspectRatio: lemGendImage.aspectRatio ? lemGendImage.aspectRatio.toFixed(2) : '0',\r\n            orientation: lemGendImage.orientation || 'unknown',\r\n            timestamp: now.getTime(),\r\n            date: this._formatDate(now, this.dateFormat),\r\n            time: this._formatDate(now, this.timeFormat),\r\n            year: now.getFullYear(),\r\n            month: String(now.getMonth() + 1).padStart(2, '0'),\r\n            day: String(now.getDate()).padStart(2, '0'),\r\n            hour: String(now.getHours()).padStart(2, '0'),\r\n            minute: String(now.getMinutes()).padStart(2, '0'),\r\n            second: String(now.getSeconds()).padStart(2, '0'),\r\n            extension: lemGendImage.extension || 'unknown',\r\n            fileSize: lemGendImage.originalSize || 0,\r\n            transparency: lemGendImage.transparency ? 'transparent' : 'opaque'\r\n        }\r\n\r\n        variables['dimensions_wxh'] = `${variables.width}x${variables.height}`\r\n        variables['dimensions_hxw'] = `${variables.height}x${variables.width}`\r\n\r\n        const totalDigits = Math.max(3, String(variables.index + 100).length - 1)\r\n        variables['index_padded'] = String(variables.index).padStart(totalDigits, '0')\r\n\r\n        return variables\r\n    }\r\n\r\n    /**\r\n     * Format date according to pattern\r\n     * @private\r\n     */\r\n    _formatDate = (date, format) => {\r\n        const replacements = {\r\n            'YYYY': date.getFullYear(),\r\n            'YY': String(date.getFullYear()).slice(-2),\r\n            'MM': String(date.getMonth() + 1).padStart(2, '0'),\r\n            'M': date.getMonth() + 1,\r\n            'DD': String(date.getDate()).padStart(2, '0'),\r\n            'D': date.getDate(),\r\n            'HH': String(date.getHours()).padStart(2, '0'),\r\n            'H': date.getHours(),\r\n            'mm': String(date.getMinutes()).padStart(2, '0'),\r\n            'm': date.getMinutes(),\r\n            'ss': String(date.getSeconds()).padStart(2, '0'),\r\n            's': date.getSeconds()\r\n        }\r\n\r\n        let result = format\r\n        for (const [key, value] of Object.entries(replacements)) {\r\n            result = result.replace(new RegExp(key, 'g'), value)\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Apply pattern with variables\r\n     * @private\r\n     */\r\n    _applyPattern = (pattern, variables) => {\r\n        let result = pattern\r\n\r\n        for (const [key, value] of Object.entries(variables)) {\r\n            const placeholder = `{${key}}`\r\n            if (result.includes(placeholder)) {\r\n                result = result.replace(new RegExp(this._escapeRegExp(placeholder), 'g'), String(value))\r\n            }\r\n        }\r\n\r\n        result = result.replace(/{[^}]+}/g, '')\r\n        result = result.replace(/[<>:\"/\\\\|?*\\x00-\\x1F]/g, '_')\r\n        result = result.replace(/[-_]{2,}/g, '-')\r\n        result = result.replace(/[ _]{2,}/g, ' ')\r\n        result = result.trim()\r\n        result = result.replace(/^[-_.]+|[-_.]+$/g, '')\r\n\r\n        return result\r\n    }\r\n\r\n    /**\r\n     * Escape regex special characters\r\n     * @private\r\n     */\r\n    _escapeRegExp = (string) => {\r\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\r\n    }\r\n\r\n    /**\r\n     * Add warnings and recommendations to result\r\n     * @private\r\n     */\r\n    _addWarningsAndRecommendations = (lemGendImage, newName, result) => {\r\n        const patternVariables = this.pattern.match(/{[^}]+}/g) || []\r\n        const usedVariables = patternVariables.map(v => v.slice(1, -1))\r\n\r\n        const hasUniqueIdentifier = usedVariables.some(v =>\r\n            ['index', 'timestamp', 'time'].includes(v)\r\n        )\r\n\r\n        if (!hasUniqueIdentifier && !this.pattern.includes('{name}')) {\r\n            result.warnings.push({\r\n                type: 'no_unique_identifier',\r\n                message: 'Pattern may create duplicate filenames',\r\n                severity: 'warning',\r\n                suggestion: 'Include {index}, {timestamp}, or {time} for unique filenames'\r\n            })\r\n        }\r\n\r\n        if (newName.length < 3) {\r\n            result.warnings.push({\r\n                type: 'very_short_name',\r\n                message: 'Filename is very short',\r\n                severity: 'warning',\r\n                suggestion: 'Consider adding more variables to the pattern'\r\n            })\r\n        }\r\n\r\n        if (newName.length > 255) {\r\n            result.warnings.push({\r\n                type: 'very_long_name',\r\n                message: 'Filename exceeds 255 characters',\r\n                severity: 'error',\r\n                suggestion: 'Simplify pattern or use shorter variable names'\r\n            })\r\n        }\r\n\r\n        const specialChars = /[~`!@#$%^&*()+=[]{}|;:',<>?]/\r\n        if (specialChars.test(newName)) {\r\n            result.warnings.push({\r\n                type: 'special_characters',\r\n                message: 'Filename contains special characters that may cause issues',\r\n                severity: 'warning',\r\n                suggestion: 'Use only letters, numbers, hyphens, and underscores'\r\n            })\r\n        }\r\n\r\n        const originalBase = lemGendImage.originalName.replace(/\\.[^/.]+$/, '')\r\n        const similarity = this._calculateSimilarity(originalBase, newName)\r\n\r\n        if (similarity < 0.3) {\r\n            result.recommendations.push({\r\n                type: 'significant_name_change',\r\n                message: 'Filename changed significantly from original',\r\n                suggestion: 'Consider including {name} variable to preserve original name reference'\r\n            })\r\n        }\r\n\r\n        if (this.pattern.includes('{index}')) {\r\n            result.metadata.sequentialNumbering = true\r\n            result.metadata.startIndex = this.startIndex\r\n            result.metadata.indexPadding = this.pattern.includes('{index_padded}') ? 'padded' : 'unpadded'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate string similarity\r\n     * @private\r\n     */\r\n    _calculateSimilarity = (str1, str2) => {\r\n        const longer = str1.length > str2.length ? str1 : str2\r\n        const shorter = str1.length > str2.length ? str2 : str1\r\n\r\n        if (longer.length === 0) {\r\n            return 1.0\r\n        }\r\n\r\n        const commonChars = shorter.split('').filter(char => longer.includes(char)).length\r\n        return commonChars / longer.length\r\n    }\r\n\r\n    /**\r\n     * Get common rename patterns\r\n     * @returns {Object} Common pattern templates\r\n     */\r\n    static getCommonPatterns() {\r\n        return {\r\n            'sequential': '{name}-{index_padded}',\r\n            'dated': '{name}-{date}',\r\n            'timestamped': '{name}-{timestamp}',\r\n            'dimensioned': '{name}-{dimensions}',\r\n            'simple': '{index_padded}',\r\n            'descriptive': '{name}-{dimensions}-{date}',\r\n            'batch': 'batch-{date}-{index_padded}',\r\n            'export': 'export-{timestamp}',\r\n            'web': '{name}-{width}w',\r\n            'social': '{name}-{dimensions}-social'\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get processor description\r\n     * @returns {string} Description\r\n     */\r\n    static getDescription() {\r\n        return 'LemGendaryRename™: Batch rename images with pattern support.'\r\n    }\r\n\r\n    /**\r\n     * Get processor information\r\n     * @returns {Object} Processor info\r\n     */\r\n    static getInfo() {\r\n        return {\r\n            name: 'LemGendaryRename',\r\n            version: '1.0.0',\r\n            description: this.getDescription(),\r\n            variables: [\r\n                '{name}', '{index}', '{index_padded}', '{width}', '{height}',\r\n                '{dimensions}', '{dimensions_wxh}', '{dimensions_hxw}',\r\n                '{aspectRatio}', '{orientation}', '{timestamp}', '{date}',\r\n                '{time}', '{year}', '{month}', '{day}', '{hour}', '{minute}',\r\n                '{second}', '{extension}', '{fileSize}', '{transparency}'\r\n            ],\r\n            commonPatterns: this.getCommonPatterns()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create processor from configuration object\r\n     * @param {Object} config - Processor configuration\r\n     * @returns {LemGendaryRename} New processor instance\r\n     */\r\n    static fromConfig(config) {\r\n        return new LemGendaryRename(config)\r\n    }\r\n}"],"names":["LemGendaryResize","options","__publicField","errors","warnings","validAlgorithms","validModes","errorMessages","e","w","lemGendImage","aspectRatio","megapixels","optionsValidation","imageValidation","originalWidth","originalHeight","originalOrientation","originalAspect","newDimensions","upscaleValidation","dimensionValidation","result","newWidth","newHeight","scale","scaleUpWidth","scaleUpHeight","dimensions","valid","width","height","scaleFactor","newAspect","aspectDiff","images","results","batchWarnings","image","error","successful","r","failed","config","targetDimension","forceSquare","mode","processor","recommendations","validTypes","canProcess","reason","LemGendaryCrop","sourceAspect","targetAspect","capabilities","canvas","faceDetector","availableFeatures","unavailableFeatures","previousDimensions","sourceWidth","sourceHeight","detectionResult","resizeResult","resizeValidation","cropResult","resizeWidth","resizeHeight","requiresUpscaling","scaleX","scaleY","focusPoint","focusX","focusY","cropX","cropY","ruleOfThirdsX","ruleOfThirdsY","thirdsPoints","bestPoint","minDistance","point","distance","totalContentArea","preservedContentArea","face","faceArea","faceCenterX","faceCenterY","object","objectArea","objectCenterX","objectCenterY","contentPreservation","imageBitmap","f","o","faces","detectedFaces","totalX","totalY","totalWeight","weight","centerX","centerY","objects","targetWidth","targetHeight","scaledWidth","scaledHeight","LemGendaryOptimize","validation","validationResult","a","b","selectedFormat","canConvert","analysis","compatibility","resizeInfo","compression","savings","ratio","scores","hasTransparency","isFavicon","isGraphic","availableFormats","format","data","score","quality","compressionLevel","lossless","isPhotographic","formatData","minDimension","originalSize","estimatedSize","areaReduction","resolve","reject","img","ctx","mimeType","blob","extension","newName","optimizationResult","optimizedFile","optimizationResults","totalOriginalSize","sum","totalOptimizedSize","totalSavings","savingsPercentage","formats","uniqueFormats","largeOriginals","LemGendaryRename","imageIndex","totalImages","variables","now","totalDigits","date","replacements","key","value","pattern","placeholder","string","v","originalBase","str1","str2","longer","shorter","char"],"mappings":"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"}